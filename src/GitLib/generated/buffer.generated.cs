//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// A data buffer for exporting data from libgit2
        /// </summary>
        /// <remarks>
        /// Sometimes libgit2 wants to return an allocated data buffer to the
        /// caller and have the caller take responsibility for freeing that memory.
        /// This can be awkward if the caller does not have easy access to the same
        /// allocation functions that libgit2 is using.  In those cases, libgit2
        /// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
        /// release it when they are done.A `git_buf` may also be used for the caller to pass in a reference to
        /// a block of memory they hold.  In this case, libgit2 will not resize or
        /// free the memory, but will read from it as needed.A `git_buf` is a public structure with three fields:- `ptr` points to the start of the allocated memory.  If it is NULL,
        /// then the `git_buf` is considered empty and libgit2 will feel free
        /// to overwrite it with new data.- `size` holds the size (in bytes) of the data that is actually used.- `asize` holds the known total amount of allocated memory if the `ptr`
        /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
        /// was not allocated by libgit2 and should not be resized and/or freed,
        /// then `asize` will be set to zero.Some APIs may occasionally do something slightly unusual with a buffer,
        /// such as setting `ptr` to a value that was passed in by the user.  In
        /// those cases, the behavior will be clearly documented by the API.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_buf
        {
            public IntPtr ptr;
            
            public size_t asize;
            
            public size_t size;
        }
        
        /// <summary>
        /// Free the memory referred to by the git_buf.
        /// </summary>
        /// <param name="buffer">The buffer to deallocate</param>
        /// <remarks>
        /// Note that this does not free the `git_buf` itself, just the memory
        /// pointed to by `buffer-&gt;ptr`.  This will not free the memory if it looks
        /// like it was not allocated internally, but it will clear the buffer back
        /// to the empty state.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_buf_dispose(ref git_buf buffer);
        
        /// <summary>
        /// Resize the buffer allocation to make more space.
        /// </summary>
        /// <param name="buffer">The buffer to be resized; may or may not be allocated yet</param>
        /// <param name="target_size">The desired available size</param>
        /// <returns>0 on success, -1 on allocation failure</returns>
        /// <remarks>
        /// This will attempt to grow the buffer to accommodate the target size.If the buffer refers to memory that was not allocated by libgit2 (i.e.
        /// the `asize` field is zero), then `ptr` will be replaced with a newly
        /// allocated block of data.  Be careful so that memory allocated by the
        /// caller is not lost.  As a special variant, if you pass `target_size` as
        /// 0 and the memory is not allocated by libgit2, this will allocate a new
        /// buffer of size `size` and copy the external data into it.Currently, this will never shrink a buffer, only expand it.If the allocation fails, this will return an error and the buffer will be
        /// marked as invalid for future operations, invaliding the contents.
        /// </remarks>
        public static git_result git_buf_grow(ref git_buf buffer, size_t target_size)
        {
            var __result__ = git_buf_grow__(ref buffer, target_size).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_buf_grow", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_buf_grow__(ref git_buf buffer, size_t target_size);
        
        /// <summary>
        /// Set buffer to a copy of some raw data.
        /// </summary>
        /// <param name="buffer">The buffer to set</param>
        /// <param name="data">The data to copy into the buffer</param>
        /// <param name="datalen">The length of the data to copy into the buffer</param>
        /// <returns>0 on success, -1 on allocation failure</returns>
        public static git_result git_buf_set(ref git_buf buffer, IntPtr data, size_t datalen)
        {
            var __result__ = git_buf_set__(ref buffer, data, datalen).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_buf_set", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_buf_set__(ref git_buf buffer, IntPtr data, size_t datalen);
        
        /// <summary>
        /// Check quickly if buffer looks like it contains binary data
        /// </summary>
        /// <param name="buf">Buffer to check</param>
        /// <returns>1 if buffer looks like non-text data</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_buf_is_binary(in git_buf buf);
        
        /// <summary>
        /// Check quickly if buffer contains a NUL byte
        /// </summary>
        /// <param name="buf">Buffer to check</param>
        /// <returns>1 if buffer contains a NUL byte</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_buf_contains_nul(in git_buf buf);
    }
}
