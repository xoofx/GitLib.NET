//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Stash flags
        /// </summary>
        [Flags]
        public enum git_stash_flags : int
        {
            /// <summary>
            /// No option, default
            /// </summary>
            GIT_STASH_DEFAULT = (int)0,
            
            /// <summary>
            /// All changes already added to the index are left intact in
            /// the working directory
            /// </summary>
            GIT_STASH_KEEP_INDEX = (int)(1 << 0),
            
            /// <summary>
            /// All untracked files are also stashed and then cleaned up
            /// from the working directory
            /// </summary>
            GIT_STASH_INCLUDE_UNTRACKED = (int)(1 << 1),
            
            /// <summary>
            /// All ignored files are also stashed and then cleaned up from
            /// the working directory
            /// </summary>
            GIT_STASH_INCLUDE_IGNORED = (int)(1 << 2),
        }
        
        /// <summary>
        /// No option, default
        /// </summary>
        public const git_stash_flags GIT_STASH_DEFAULT = git_stash_flags.GIT_STASH_DEFAULT;
        
        /// <summary>
        /// All changes already added to the index are left intact in
        /// the working directory
        /// </summary>
        public const git_stash_flags GIT_STASH_KEEP_INDEX = git_stash_flags.GIT_STASH_KEEP_INDEX;
        
        /// <summary>
        /// All untracked files are also stashed and then cleaned up
        /// from the working directory
        /// </summary>
        public const git_stash_flags GIT_STASH_INCLUDE_UNTRACKED = git_stash_flags.GIT_STASH_INCLUDE_UNTRACKED;
        
        /// <summary>
        /// All ignored files are also stashed and then cleaned up from
        /// the working directory
        /// </summary>
        public const git_stash_flags GIT_STASH_INCLUDE_IGNORED = git_stash_flags.GIT_STASH_INCLUDE_IGNORED;
        
        /// <summary>
        /// Stash application flags.
        /// </summary>
        [Flags]
        public enum git_stash_apply_flags : int
        {
            GIT_STASH_APPLY_DEFAULT = (int)0,
            
            /// <summary>
            /// Try to reinstate not only the working tree's changes,
            /// but also the index's changes.
            /// </summary>
            GIT_STASH_APPLY_REINSTATE_INDEX = (int)(1 << 0),
        }
        
        public const git_stash_apply_flags GIT_STASH_APPLY_DEFAULT = git_stash_apply_flags.GIT_STASH_APPLY_DEFAULT;
        
        /// <summary>
        /// Try to reinstate not only the working tree's changes,
        /// but also the index's changes.
        /// </summary>
        public const git_stash_apply_flags GIT_STASH_APPLY_REINSTATE_INDEX = git_stash_apply_flags.GIT_STASH_APPLY_REINSTATE_INDEX;
        
        /// <summary>
        /// Stash apply progression states
        /// </summary>
        public enum git_stash_apply_progress_t : int
        {
            GIT_STASH_APPLY_PROGRESS_NONE = (int)0,
            
            /// <summary>
            /// Loading the stashed data from the object database.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
            
            /// <summary>
            /// The stored index is being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
            
            /// <summary>
            /// The modified files are being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
            
            /// <summary>
            /// The untracked and ignored files are being analyzed.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
            
            /// <summary>
            /// The untracked files are being written to disk.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
            
            /// <summary>
            /// The modified files are being written to disk.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
            
            /// <summary>
            /// The stash was applied successfully.
            /// </summary>
            GIT_STASH_APPLY_PROGRESS_DONE,
        }
        
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_NONE = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_NONE;
        
        /// <summary>
        /// Loading the stashed data from the object database.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_LOADING_STASH = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_LOADING_STASH;
        
        /// <summary>
        /// The stored index is being analyzed.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX;
        
        /// <summary>
        /// The modified files are being analyzed.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED;
        
        /// <summary>
        /// The untracked and ignored files are being analyzed.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED;
        
        /// <summary>
        /// The untracked files are being written to disk.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED;
        
        /// <summary>
        /// The modified files are being written to disk.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED;
        
        /// <summary>
        /// The stash was applied successfully.
        /// </summary>
        public const git_stash_apply_progress_t GIT_STASH_APPLY_PROGRESS_DONE = git_stash_apply_progress_t.GIT_STASH_APPLY_PROGRESS_DONE;
        
        /// <summary>
        /// Stash application options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
        /// use `git_stash_apply_init_options`.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_stash_apply_options
        {
            public uint version;
            
            /// <summary>
            /// See `git_stash_apply_flags_t`, above.
            /// </summary>
            public git_stash_apply_flags flags;
            
            /// <summary>
            /// Options to use when writing files to the working directory.
            /// </summary>
            public git_checkout_options checkout_options;
            
            /// <summary>
            /// Optional callback to notify the consumer of application progress.
            /// </summary>
            public git_stash_apply_progress_cb progress_cb;
            
            public IntPtr progress_payload;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_stash_apply_progress_cb(git_stash_apply_progress_t progress, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_stash_cb(size_t index, [MarshalAs(UnmanagedType.LPUTF8Str)] string message, in git_oid stash_id, IntPtr payload);
        
        /// <summary>
        /// Save the local modifications to a new stash.
        /// </summary>
        /// <param name="out">Object id of the commit containing the stashed state.
        /// This commit is also the target of the direct reference refs/stash.</param>
        /// <param name="repo">The owning repository.</param>
        /// <param name="stasher">The identity of the person performing the stashing.</param>
        /// <param name="message">Optional description along with the stashed state.</param>
        /// <param name="flags">Flags to control the stashing process. (see GIT_STASH_* above)</param>
        /// <returns>0 on success, GIT_ENOTFOUND where there's nothing to stash,
        /// or error code.</returns>
        public static git_result git_stash_save(out git_oid @out, git_repository repo, in git_signature stasher, [MarshalAs(UnmanagedType.LPUTF8Str)] string message, uint flags)
        {
            var __result__ = git_stash_save__(out @out, repo, stasher, message, flags).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_save", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_save__(out git_oid @out, git_repository repo, in git_signature stasher, [MarshalAs(UnmanagedType.LPUTF8Str)] string message, uint flags);
        
        /// <summary>
        /// Initialize git_stash_apply_options structure
        /// </summary>
        /// <param name="opts">The `git_stash_apply_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_stash_apply_options` with default values. Equivalent to
        /// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_stash_apply_init_options(ref git_stash_apply_options opts, uint version)
        {
            var __result__ = git_stash_apply_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_apply_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_apply_init_options__(ref git_stash_apply_options opts, uint version);
        
        /// <summary>
        /// Apply a single stashed state from the stash list.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <param name="options">Optional options to control how stashes are applied.</param>
        /// <returns>0 on success, GIT_ENOTFOUND if there's no stashed state for the
        /// given index, GIT_EMERGECONFLICT if changes exist in the working
        /// directory, or an error code</returns>
        /// <remarks>
        /// If local changes in the working directory conflict with changes in the
        /// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
        /// will always remain unmodified and all files in the working directory will
        /// remain unmodified.  However, if you are restoring untracked files or
        /// ignored files and there is a conflict when applying the modified files,
        /// then those files will remain in the working directory.If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
        /// conflicts when reinstating the index, the function will return
        /// GIT_EMERGECONFLICT and both the working directory and index will be left
        /// unmodified.Note that a minimum checkout strategy of `GIT_CHECKOUT_SAFE` is implied.
        /// </remarks>
        public static git_result git_stash_apply(git_repository repo, size_t index, in git_stash_apply_options options)
        {
            var __result__ = git_stash_apply__(repo, index, options).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_apply", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_apply__(git_repository repo, size_t index, in git_stash_apply_options options);
        
        /// <summary>
        /// Loop over all the stashed states and issue a callback for each one.
        /// </summary>
        /// <param name="repo">Repository where to find the stash.</param>
        /// <param name="callback">Callback to invoke per found stashed state. The most
        /// recent stash state will be enumerated first.</param>
        /// <param name="payload">Extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code.</returns>
        /// <remarks>
        /// If the callback returns a non-zero value, this will stop looping.
        /// </remarks>
        public static git_result git_stash_foreach(git_repository repo, git_stash_cb callback, IntPtr payload)
        {
            var __result__ = git_stash_foreach__(repo, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_foreach__(git_repository repo, git_stash_cb callback, IntPtr payload);
        
        /// <summary>
        /// Remove a single stashed state from the stash list.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <returns>0 on success, GIT_ENOTFOUND if there's no stashed state for the given
        /// index, or error code.</returns>
        public static git_result git_stash_drop(git_repository repo, size_t index)
        {
            var __result__ = git_stash_drop__(repo, index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_drop", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_drop__(git_repository repo, size_t index);
        
        /// <summary>
        /// Apply a single stashed state from the stash list and remove it from the list
        /// if successful.
        /// </summary>
        /// <param name="repo">The owning repository.</param>
        /// <param name="index">The position within the stash list. 0 points to the
        /// most recent stashed state.</param>
        /// <param name="options">Optional options to control how stashes are applied.</param>
        /// <returns>0 on success, GIT_ENOTFOUND if there's no stashed state for the given
        /// index, or error code. (see git_stash_apply() above for details)</returns>
        public static git_result git_stash_pop(git_repository repo, size_t index, in git_stash_apply_options options)
        {
            var __result__ = git_stash_pop__(repo, index, options).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_stash_pop", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_stash_pop__(git_repository repo, size_t index, in git_stash_apply_options options);
    }
}
