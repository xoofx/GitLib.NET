//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Options for bypassing the git-aware transport on clone. Bypassing
        /// it means that instead of a fetch, libgit2 will copy the object
        /// database directory instead of figuring out what it needs, which is
        /// faster. If possible, it will hardlink the files to save space.
        /// </summary>
        public enum git_clone_local_t : int
        {
            /// <summary>
            /// Auto-detect (default), libgit2 will bypass the git-aware
            /// transport for local paths, but use a normal fetch for
            /// `file://` urls.
            /// </summary>
            GIT_CLONE_LOCAL_AUTO,
            
            /// <summary>
            /// Bypass the git-aware transport even for a `file://` url.
            /// </summary>
            GIT_CLONE_LOCAL,
            
            /// <summary>
            /// Do no bypass the git-aware transport
            /// </summary>
            GIT_CLONE_NO_LOCAL,
            
            /// <summary>
            /// Bypass the git-aware transport, but do not try to use
            /// hardlinks.
            /// </summary>
            GIT_CLONE_LOCAL_NO_LINKS,
        }
        
        /// <summary>
        /// Auto-detect (default), libgit2 will bypass the git-aware
        /// transport for local paths, but use a normal fetch for
        /// `file://` urls.
        /// </summary>
        public const git_clone_local_t GIT_CLONE_LOCAL_AUTO = git_clone_local_t.GIT_CLONE_LOCAL_AUTO;
        
        /// <summary>
        /// Bypass the git-aware transport even for a `file://` url.
        /// </summary>
        public const git_clone_local_t GIT_CLONE_LOCAL = git_clone_local_t.GIT_CLONE_LOCAL;
        
        /// <summary>
        /// Do no bypass the git-aware transport
        /// </summary>
        public const git_clone_local_t GIT_CLONE_NO_LOCAL = git_clone_local_t.GIT_CLONE_NO_LOCAL;
        
        /// <summary>
        /// Bypass the git-aware transport, but do not try to use
        /// hardlinks.
        /// </summary>
        public const git_clone_local_t GIT_CLONE_LOCAL_NO_LINKS = git_clone_local_t.GIT_CLONE_LOCAL_NO_LINKS;
        
        /// <summary>
        /// Clone options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_clone_init_options`.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_clone_options
        {
            public uint version;
            
            /// <summary>
            /// These options are passed to the checkout step. To disable
            /// checkout, set the `checkout_strategy` to
            /// `GIT_CHECKOUT_NONE`.
            /// </summary>
            public git_checkout_options checkout_opts;
            
            /// <summary>
            /// Options which control the fetch, including callbacks.
            /// </summary>
            /// <remarks>
            /// The callbacks are used for reporting fetch progress, and for acquiring
            /// credentials in the event they are needed.
            /// </remarks>
            public git_fetch_options fetch_opts;
            
            /// <summary>
            /// Set to zero (false) to create a standard repo, or non-zero
            /// for a bare repo
            /// </summary>
            public int bare;
            
            /// <summary>
            /// Whether to use a fetch or copy the object database.
            /// </summary>
            public git_clone_local_t local;
            
            /// <summary>
            /// The name of the branch to checkout. NULL means use the
            /// remote's default branch.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))]
            public string checkout_branch;
            
            /// <summary>
            /// A callback used to create the new repository into which to
            /// clone. If NULL, the 'bare' field will be used to determine
            /// whether to create a bare repository.
            /// </summary>
            public git_repository_create_cb repository_cb;
            
            /// <summary>
            /// An opaque payload to pass to the git_repository creation callback.
            /// This parameter is ignored unless repository_cb is non-NULL.
            /// </summary>
            public IntPtr repository_cb_payload;
            
            /// <summary>
            /// A callback used to create the git_remote, prior to its being
            /// used to perform the clone operation. See the documentation for
            /// git_remote_create_cb for details. This parameter may be NULL,
            /// indicating that git_clone should provide default behavior.
            /// </summary>
            public git_remote_create_cb remote_cb;
            
            /// <summary>
            /// An opaque payload to pass to the git_remote creation callback.
            /// This parameter is ignored unless remote_cb is non-NULL.
            /// </summary>
            public IntPtr remote_cb_payload;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_repository_create_cb(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, int bare, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_remote_create_cb(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string url, IntPtr payload);
        
        /// <summary>
        /// Initialize git_clone_options structure
        /// </summary>
        /// <param name="opts">The `git_clone_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_clone_options` with default values. Equivalent to creating
        /// an instance with GIT_CLONE_OPTIONS_INIT.
        /// </remarks>
        public static git_result git_clone_init_options(ref git_clone_options opts, uint version)
        {
            var __result__ = git_clone_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_clone_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_clone_init_options__(ref git_clone_options opts, uint version);
        
        /// <summary>
        /// Clone a remote repository.
        /// </summary>
        /// <param name="out">pointer that will receive the resulting repository object</param>
        /// <param name="url">the remote repository to clone</param>
        /// <param name="local_path">local directory to clone to</param>
        /// <param name="options">configuration options for the clone.  If NULL, the
        /// function works as though GIT_OPTIONS_INIT were passed.</param>
        /// <returns>0 on success, any non-zero return value from a callback
        /// function, or a negative value to indicate an error (use
        /// `git_error_last` for a detailed error message)</returns>
        /// <remarks>
        /// By default this creates its repository and initial remote to match
        /// git's defaults. You can use the options in the callback to
        /// customize how these are created.
        /// </remarks>
        public static git_result git_clone(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string url, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string local_path, in git_clone_options options)
        {
            var __result__ = git_clone__(out @out, url, local_path, options).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_clone", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_clone__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string url, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string local_path, in git_clone_options options);
    }
}
