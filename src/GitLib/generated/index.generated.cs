//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Flags for index entries
        /// </summary>
        public enum git_index_entry_flag_t : int
        {
            GIT_INDEX_ENTRY_EXTENDED = (int)(0x4000),
            
            GIT_INDEX_ENTRY_VALID = (int)(0x8000),
        }
        
        public const git_index_entry_flag_t GIT_INDEX_ENTRY_EXTENDED = git_index_entry_flag_t.GIT_INDEX_ENTRY_EXTENDED;
        
        public const git_index_entry_flag_t GIT_INDEX_ENTRY_VALID = git_index_entry_flag_t.GIT_INDEX_ENTRY_VALID;
        
        /// <summary>
        /// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
        /// </summary>
        /// <remarks>
        /// In memory, the `flags_extended` fields are divided into two parts: the
        /// fields that are read from and written to disk, and other fields that
        /// in-memory only and used by libgit2.  Only the flags in
        /// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.Thee first three bitmasks match the three fields in the
        /// `git_index_entry` `flags_extended` value that belong on disk.  You
        /// can use them to interpret the data in the `flags_extended`.The rest of the bitmasks match the other fields in the `git_index_entry`
        /// `flags_extended` value that are only used in-memory by libgit2.
        /// You can use them to interpret the data in the `flags_extended`.
        /// </remarks>
        [Flags]
        public enum git_index_entry_extended_flag_t : int
        {
            GIT_INDEX_ENTRY_INTENT_TO_ADD = (int)(1 << 13),
            
            GIT_INDEX_ENTRY_SKIP_WORKTREE = (int)(1 << 14),
            
            GIT_INDEX_ENTRY_EXTENDED_FLAGS = (int)(GIT_INDEX_ENTRY_INTENT_TO_ADD | GIT_INDEX_ENTRY_SKIP_WORKTREE),
            
            GIT_INDEX_ENTRY_UPTODATE = (int)(1 << 2),
        }
        
        public const git_index_entry_extended_flag_t GIT_INDEX_ENTRY_INTENT_TO_ADD = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_INTENT_TO_ADD;
        
        public const git_index_entry_extended_flag_t GIT_INDEX_ENTRY_SKIP_WORKTREE = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_SKIP_WORKTREE;
        
        public const git_index_entry_extended_flag_t GIT_INDEX_ENTRY_EXTENDED_FLAGS = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_EXTENDED_FLAGS;
        
        public const git_index_entry_extended_flag_t GIT_INDEX_ENTRY_UPTODATE = git_index_entry_extended_flag_t.GIT_INDEX_ENTRY_UPTODATE;
        
        /// <summary>
        /// Capabilities of system that affect index actions.
        /// </summary>
        public enum git_index_capability_t : int
        {
            GIT_INDEX_CAPABILITY_IGNORE_CASE = (int)1,
            
            GIT_INDEX_CAPABILITY_NO_FILEMODE = (int)2,
            
            GIT_INDEX_CAPABILITY_NO_SYMLINKS = (int)4,
            
            GIT_INDEX_CAPABILITY_FROM_OWNER = (int)-1,
        }
        
        public const git_index_capability_t GIT_INDEX_CAPABILITY_IGNORE_CASE = git_index_capability_t.GIT_INDEX_CAPABILITY_IGNORE_CASE;
        
        public const git_index_capability_t GIT_INDEX_CAPABILITY_NO_FILEMODE = git_index_capability_t.GIT_INDEX_CAPABILITY_NO_FILEMODE;
        
        public const git_index_capability_t GIT_INDEX_CAPABILITY_NO_SYMLINKS = git_index_capability_t.GIT_INDEX_CAPABILITY_NO_SYMLINKS;
        
        public const git_index_capability_t GIT_INDEX_CAPABILITY_FROM_OWNER = git_index_capability_t.GIT_INDEX_CAPABILITY_FROM_OWNER;
        
        /// <summary>
        /// Flags for APIs that add files matching pathspec
        /// </summary>
        [Flags]
        public enum git_index_add_option_t : int
        {
            GIT_INDEX_ADD_DEFAULT = (int)0,
            
            GIT_INDEX_ADD_FORCE = (int)(1u<<0),
            
            GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = (int)(1u<<1),
            
            GIT_INDEX_ADD_CHECK_PATHSPEC = (int)(1u<<2),
        }
        
        public const git_index_add_option_t GIT_INDEX_ADD_DEFAULT = git_index_add_option_t.GIT_INDEX_ADD_DEFAULT;
        
        public const git_index_add_option_t GIT_INDEX_ADD_FORCE = git_index_add_option_t.GIT_INDEX_ADD_FORCE;
        
        public const git_index_add_option_t GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = git_index_add_option_t.GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH;
        
        public const git_index_add_option_t GIT_INDEX_ADD_CHECK_PATHSPEC = git_index_add_option_t.GIT_INDEX_ADD_CHECK_PATHSPEC;
        
        public enum git_index_stage_t : int
        {
            /// <summary>
            /// Match any index stage.
            /// </summary>
            /// <remarks>
            /// Some index APIs take a stage to match; pass this value to match
            /// any entry matching the path regardless of stage.
            /// </remarks>
            GIT_INDEX_STAGE_ANY = (int)-1,
            
            /// <summary>
            /// A normal staged file in the index.
            /// </summary>
            GIT_INDEX_STAGE_NORMAL = (int)0,
            
            /// <summary>
            /// The ancestor side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_ANCESTOR = (int)1,
            
            /// <summary>
            /// The "ours" side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_OURS = (int)2,
            
            /// <summary>
            /// The "theirs" side of a conflict.
            /// </summary>
            GIT_INDEX_STAGE_THEIRS = (int)3,
        }
        
        /// <summary>
        /// Match any index stage.
        /// </summary>
        /// <remarks>
        /// Some index APIs take a stage to match; pass this value to match
        /// any entry matching the path regardless of stage.
        /// </remarks>
        public const git_index_stage_t GIT_INDEX_STAGE_ANY = git_index_stage_t.GIT_INDEX_STAGE_ANY;
        
        /// <summary>
        /// A normal staged file in the index.
        /// </summary>
        public const git_index_stage_t GIT_INDEX_STAGE_NORMAL = git_index_stage_t.GIT_INDEX_STAGE_NORMAL;
        
        /// <summary>
        /// The ancestor side of a conflict.
        /// </summary>
        public const git_index_stage_t GIT_INDEX_STAGE_ANCESTOR = git_index_stage_t.GIT_INDEX_STAGE_ANCESTOR;
        
        /// <summary>
        /// The "ours" side of a conflict.
        /// </summary>
        public const git_index_stage_t GIT_INDEX_STAGE_OURS = git_index_stage_t.GIT_INDEX_STAGE_OURS;
        
        /// <summary>
        /// The "theirs" side of a conflict.
        /// </summary>
        public const git_index_stage_t GIT_INDEX_STAGE_THEIRS = git_index_stage_t.GIT_INDEX_STAGE_THEIRS;
        
        /// <summary>
        /// Time structure used in a git index entry
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_index_time
        {
            public int seconds;
            
            /// <summary>
            /// nsec should not be stored as time_t compatible
            /// </summary>
            public uint nanoseconds;
        }
        
        /// <summary>
        /// In-memory representation of a file entry in the index.
        /// </summary>
        /// <remarks>
        /// This is a public structure that represents a file entry in the index.
        /// The meaning of the fields corresponds to core Git's documentation (in
        /// "Documentation/technical/index-format.txt").The `flags` field consists of a number of bit fields which can be
        /// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
        /// These flags are all read from and persisted to disk.The `flags_extended` field also has a number of bit fields which can be
        /// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
        /// these flags are read from and written to disk, but some are set aside
        /// for in-memory only reference.Note that the time and size fields are truncated to 32 bits. This
        /// is enough to detect changes, which is enough for the index to
        /// function as a cache, but it should not be taken as an authoritative
        /// source for that data.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_index_entry
        {
            public git_index_time ctime;
            
            public git_index_time mtime;
            
            public uint dev;
            
            public uint ino;
            
            public uint mode;
            
            public uint uid;
            
            public uint gid;
            
            public uint file_size;
            
            public git_oid id;
            
            public ushort flags;
            
            public ushort flags_extended;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))]
            public string path;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_index_matched_path_cb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string matched_pathspec, IntPtr payload);
        
        /// <summary>
        /// Create a new bare Git index object as a memory representation
        /// of the Git index file in 'index_path', without a repository
        /// to back it.
        /// </summary>
        /// <param name="out">the pointer for the new index</param>
        /// <param name="index_path">the path to the index file in disk</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Since there is no ODB or working directory behind this index,
        /// any Index methods which rely on these (e.g. index_add_bypath)
        /// will fail with the GIT_ERROR error code.If you need to access the index of an actual repository,
        /// use the `git_repository_index` wrapper.The index must be freed once it's no longer in use.
        /// </remarks>
        public static git_result git_index_open(out git_index @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string index_path)
        {
            var __result__ = git_index_open__(out @out, index_path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_open", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_open__(out git_index @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string index_path);
        
        /// <summary>
        /// Create an in-memory index object.
        /// </summary>
        /// <param name="out">the pointer for the new index</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This index object cannot be read/written to the filesystem,
        /// but may be used to perform in-memory index operations.The index must be freed once it's no longer in use.
        /// </remarks>
        public static git_result git_index_new(out git_index @out)
        {
            var __result__ = git_index_new__(out @out).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_new__(out git_index @out);
        
        /// <summary>
        /// Free an existing index object.
        /// </summary>
        /// <param name="index">an existing index object</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_index_free(git_index index);
        
        /// <summary>
        /// Get the repository this index relates to
        /// </summary>
        /// <param name="index">The index</param>
        /// <returns>A pointer to the repository</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_index_owner(git_index index);
        
        /// <summary>
        /// Read index capabilities flags.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <returns>A combination of GIT_INDEX_CAPABILITY values</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_caps(git_index index);
        
        /// <summary>
        /// Set index capabilities flags.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="caps">A combination of GIT_INDEX_CAPABILITY values</param>
        /// <returns>0 on success, -1 on failure</returns>
        /// <remarks>
        /// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
        /// capabilities will be read from the config of the owner object,
        /// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
        /// </remarks>
        public static git_result git_index_set_caps(git_index index, int caps)
        {
            var __result__ = git_index_set_caps__(index, caps).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_set_caps", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_set_caps__(git_index index, int caps);
        
        /// <summary>
        /// Get index on-disk version.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <returns>the index version</returns>
        /// <remarks>
        /// Valid return values are 2, 3, or 4.  If 3 is returned, an index
        /// with version 2 may be written instead, if the extension data in
        /// version 3 is not necessary.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint git_index_version(git_index index);
        
        /// <summary>
        /// Set index on-disk version.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="version">The new version number</param>
        /// <returns>0 on success, -1 on failure</returns>
        /// <remarks>
        /// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
        /// write an index with version 3 instead, if necessary to accurately
        /// represent the index.
        /// </remarks>
        public static git_result git_index_set_version(git_index index, uint version)
        {
            var __result__ = git_index_set_version__(index, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_set_version", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_set_version__(git_index index, uint version);
        
        /// <summary>
        /// Update the contents of an existing index object in memory by reading
        /// from the hard disk.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="force">if true, always reload, vs. only read if file has changed</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// If `force` is true, this performs a "hard" read that discards in-memory
        /// changes and always reloads the on-disk index data.  If there is no
        /// on-disk version, the index will be cleared.If `force` is false, this does a "soft" read that reloads the index
        /// data from disk only if it has changed since the last time it was
        /// loaded.  Purely in-memory index data will be untouched.  Be aware: if
        /// there are changes on disk, unwritten in-memory changes are discarded.
        /// </remarks>
        public static git_result git_index_read(git_index index, int force)
        {
            var __result__ = git_index_read__(index, force).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_read", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_read__(git_index index, int force);
        
        /// <summary>
        /// Write an existing index object from memory back to disk
        /// using an atomic file lock.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_index_write(git_index index)
        {
            var __result__ = git_index_write__(index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_write", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_write__(git_index index);
        
        /// <summary>
        /// Get the full path to the index file on disk.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>path to index file or NULL for in-memory index</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static extern string git_index_path(git_index index);
        
        /// <summary>
        /// Get the checksum of the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>a pointer to the checksum of the index</returns>
        /// <remarks>
        /// This checksum is the SHA-1 hash over the index file (except the
        /// last 20 bytes which are the checksum itself). In cases where the
        /// index does not exist on-disk, it will be zeroed out.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_index_checksum(git_index index);
        
        /// <summary>
        /// Read a tree into the index file with stats
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="tree">tree to read</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The current index contents will be replaced by the specified tree.
        /// </remarks>
        public static git_result git_index_read_tree(git_index index, git_tree tree)
        {
            var __result__ = git_index_read_tree__(index, tree).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_read_tree", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_read_tree__(git_index index, git_tree tree);
        
        /// <summary>
        /// Write the index as a tree
        /// </summary>
        /// <param name="out">Pointer where to store the OID of the written tree</param>
        /// <param name="index">Index to write</param>
        /// <returns>0 on success, GIT_EUNMERGED when the index is not clean
        /// or an error code</returns>
        /// <remarks>
        /// This method will scan the index and write a representation
        /// of its current state back to disk; it recursively creates
        /// tree objects for each of the subtrees stored in the index,
        /// but only returns the OID of the root tree. This is the OID
        /// that can be used e.g. to create a commit.The index instance cannot be bare, and needs to be associated
        /// to an existing repository.The index must not contain any file in conflict.
        /// </remarks>
        public static git_result git_index_write_tree(out git_oid @out, git_index index)
        {
            var __result__ = git_index_write_tree__(out @out, index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_write_tree", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_write_tree__(out git_oid @out, git_index index);
        
        /// <summary>
        /// Write the index as a tree to the given repository
        /// </summary>
        /// <param name="out">Pointer where to store OID of the the written tree</param>
        /// <param name="index">Index to write</param>
        /// <param name="repo">Repository where to write the tree</param>
        /// <returns>0 on success, GIT_EUNMERGED when the index is not clean
        /// or an error code</returns>
        /// <remarks>
        /// This method will do the same as `git_index_write_tree`, but
        /// letting the user choose the repository where the tree will
        /// be written.The index must not contain any file in conflict.
        /// </remarks>
        public static git_result git_index_write_tree_to(out git_oid @out, git_index index, git_repository repo)
        {
            var __result__ = git_index_write_tree_to__(out @out, index, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_write_tree_to", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_write_tree_to__(out git_oid @out, git_index index, git_repository repo);
        
        /// <summary>
        /// Get the count of entries currently in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>integer of count of current entries</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern size_t git_index_entrycount(git_index index);
        
        /// <summary>
        /// Clear the contents (all the entries) of an index object.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>0 on success, error code 
        /// &lt;
        /// 0 on failure</returns>
        /// <remarks>
        /// This clears the index object in memory; changes must be explicitly
        /// written to disk for them to take effect persistently.
        /// </remarks>
        public static git_result git_index_clear(git_index index)
        {
            var __result__ = git_index_clear__(index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_clear", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_clear__(git_index index);
        
        /// <summary>
        /// Get a pointer to one of the entries in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="n">the position of the entry</param>
        /// <returns>a pointer to the entry; NULL if out of bounds</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_index_entry git_index_get_byindex(git_index index, size_t n);
        
        /// <summary>
        /// Get a pointer to one of the entries in the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>a pointer to the entry; NULL if it was not found</returns>
        /// <remarks>
        /// The entry is not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_index_entry git_index_get_bypath(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, int stage);
        
        /// <summary>
        /// Remove an entry from the index
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <param name="stage">stage to search</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_index_remove(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, int stage)
        {
            var __result__ = git_index_remove__(index, path, stage).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_remove", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_remove__(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, int stage);
        
        /// <summary>
        /// Remove all entries from the index under a given directory
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="dir">container directory path</param>
        /// <param name="stage">stage to search</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_index_remove_directory(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string dir, int stage)
        {
            var __result__ = git_index_remove_directory__(index, dir, stage).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_remove_directory", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_remove_directory__(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string dir, int stage);
        
        /// <summary>
        /// Add or update an index entry from an in-memory struct
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="source_entry">new entry object</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// If a previous index entry exists that has the same path and stage
        /// as the given 'source_entry', it will be replaced.  Otherwise, the
        /// 'source_entry' will be added.A full copy (including the 'path' string) of the given
        /// 'source_entry' will be inserted on the index.
        /// </remarks>
        public static git_result git_index_add(git_index index, in git_index_entry source_entry)
        {
            var __result__ = git_index_add__(index, source_entry).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_add", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_add__(git_index index, in git_index_entry source_entry);
        
        /// <summary>
        /// Return the stage number from a git index entry
        /// </summary>
        /// <param name="entry">The entry</param>
        /// <returns>the stage number</returns>
        /// <remarks>
        /// This entry is calculated from the entry's flag attribute like this:(entry-&gt;flags 
        /// &amp;
        /// GIT_INDEX_ENTRY_STAGEMASK) &gt;&gt; GIT_INDEX_ENTRY_STAGESHIFT
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_entry_stage(in git_index_entry entry);
        
        /// <summary>
        /// Return whether the given index entry is a conflict (has a high stage
        /// entry).  This is simply shorthand for `git_index_entry_stage &gt; 0`.
        /// </summary>
        /// <param name="entry">The entry</param>
        /// <returns>1 if the entry is a conflict entry, 0 otherwise</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_entry_is_conflict(in git_index_entry entry);
        
        /// <summary>
        /// Create an iterator that will return every entry contained in the
        /// index at the time of creation.  Entries are returned in order,
        /// sorted by path.  This iterator is backed by a snapshot that allows
        /// callers to modify the index while iterating without affecting the
        /// iterator.
        /// </summary>
        /// <param name="iterator_out">The newly created iterator</param>
        /// <param name="index">The index to iterate</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_iterator_new(out git_index_iterator iterator_out, git_index index);
        
        /// <summary>
        /// Return the next index entry in-order from the iterator.
        /// </summary>
        /// <param name="out">Pointer to store the index entry in</param>
        /// <param name="iterator">The iterator</param>
        /// <returns>0, GIT_ITEROVER on iteration completion or an error code</returns>
        public static git_result git_index_iterator_next(out IntPtr @out, git_index_iterator iterator)
        {
            var __result__ = git_index_iterator_next__(out @out, iterator).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_iterator_next", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_iterator_next__(out IntPtr @out, git_index_iterator iterator);
        
        /// <summary>
        /// Free the index iterator
        /// </summary>
        /// <param name="iterator">The iterator to free</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_index_iterator_free(git_index_iterator iterator);
        
        /// <summary>
        /// Add or update an index entry from a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to add</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder and must be readable.This method will fail in bare index instances.This forces the file to be added to the index, not looking
        /// at gitignore rules.  Those rules can be evaluated through
        /// the git_status APIs (in status.h) before calling this.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        public static git_result git_index_add_bypath(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_index_add_bypath__(index, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_add_bypath", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_add_bypath__(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Add or update an index entry from a buffer in memory
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="entry">filename to add</param>
        /// <param name="buffer">data to be written into the blob</param>
        /// <param name="len">length of the data</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This method will create a blob in the repository that owns the
        /// index and then add the index entry to the index.  The `path` of the
        /// entry represents the position of the blob relative to the
        /// repository's root folder.If a previous index entry exists that has the same path as the
        /// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
        /// added. The `id` and the `file_size` of the 'entry' are updated with the
        /// real value of the blob.This forces the file to be added to the index, not looking
        /// at gitignore rules.  Those rules can be evaluated through
        /// the git_status APIs (in status.h) before calling this.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        public static git_result git_index_add_frombuffer(git_index index, in git_index_entry entry, IntPtr buffer, size_t len)
        {
            var __result__ = git_index_add_frombuffer__(index, entry, buffer, len).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_add_frombuffer", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_add_frombuffer__(git_index index, in git_index_entry entry, IntPtr buffer, size_t len);
        
        /// <summary>
        /// Remove an index entry corresponding to a file on disk
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">filename to remove</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The file `path` must be relative to the repository's
        /// working folder.  It may exist.If this file currently is the result of a merge conflict, this
        /// file will no longer be marked as conflicting.  The data about
        /// the conflict will be moved to the "resolve undo" (REUC) section.
        /// </remarks>
        public static git_result git_index_remove_bypath(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_index_remove_bypath__(index, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_remove_bypath", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_remove_bypath__(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Add or update index entries matching files in the working directory.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="flags">combination of git_index_add_option_t flags</param>
        /// <param name="callback">notification callback for each added/updated path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// This method will fail in bare index instances.The `pathspec` is a list of file names or shell glob patterns that will
        /// be matched against files in the repository's working directory.  Each
        /// file that matches will be added to the index (either updating an
        /// existing entry or adding a new entry).  You can disable glob expansion
        /// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
        /// flag.Files that are ignored will be skipped (unlike `git_index_add_bypath`).
        /// If a file is already tracked in the index, then it *will* be updated
        /// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
        /// the checking of ignore rules.To emulate `git add -A` and generate an error if the pathspec contains
        /// the exact path of an ignored file (when not using FORCE), add the
        /// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
        /// in the `pathspec` that is an exact match to a filename on disk is
        /// either not ignored or already in the index.  If this check fails, the
        /// function will return GIT_EINVALIDSPEC.To emulate `git add -A` with the "dry-run" option, just use a callback
        /// function that always returns a positive value.  See below for details.If any files are currently the result of a merge conflict, those files
        /// will no longer be marked as conflicting.  The data about the conflicts
        /// will be moved to the "resolve undo" (REUC) section.If you provide a callback function, it will be invoked on each matching
        /// item in the working directory immediately *before* it is added to /
        /// updated in the index.  Returning zero will add the item to the index,
        /// greater than zero will skip the item, and less than zero will abort the
        /// scan and return that value to the caller.
        /// </remarks>
        public static git_result git_index_add_all(git_index index, string[] pathspec, uint flags, git_index_matched_path_cb callback, IntPtr payload)
        {
            var pathspec__ = git_strarray.Allocate(pathspec);
            var __result__ = git_index_add_all__(index, in pathspec__, flags, callback, payload);
            pathspec__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_add_all", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_add_all__(git_index index, in git_strarray pathspec, uint flags, git_index_matched_path_cb callback, IntPtr payload);
        
        /// <summary>
        /// Remove all matching index entries.
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="callback">notification callback for each removed path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// If you provide a callback function, it will be invoked on each matching
        /// item in the index immediately *before* it is removed.  Return 0 to
        /// remove the item, &gt; 0 to skip the item, and 
        /// &lt;
        /// 0 to abort the scan.
        /// </remarks>
        public static git_result git_index_remove_all(git_index index, string[] pathspec, git_index_matched_path_cb callback, IntPtr payload)
        {
            var pathspec__ = git_strarray.Allocate(pathspec);
            var __result__ = git_index_remove_all__(index, in pathspec__, callback, payload);
            pathspec__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_remove_all", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_remove_all__(git_index index, in git_strarray pathspec, git_index_matched_path_cb callback, IntPtr payload);
        
        /// <summary>
        /// Update all index entries to match the working directory
        /// </summary>
        /// <param name="index">An existing index object</param>
        /// <param name="pathspec">array of path patterns</param>
        /// <param name="callback">notification callback for each updated path (also
        /// gets index of matching pathspec entry); can be NULL;
        /// return 0 to add, &gt;0 to skip, 
        /// &lt;
        /// 0 to abort scan.</param>
        /// <param name="payload">payload passed through to callback function</param>
        /// <returns>0 on success, negative callback return value, or error code</returns>
        /// <remarks>
        /// This method will fail in bare index instances.This scans the existing index entries and synchronizes them with the
        /// working directory, deleting them if the corresponding working directory
        /// file no longer exists otherwise updating the information (including
        /// adding the latest version of file to the ODB if needed).If you provide a callback function, it will be invoked on each matching
        /// item in the index immediately *before* it is updated (either refreshed
        /// or removed depending on working directory state).  Return 0 to proceed
        /// with updating the item, &gt; 0 to skip the item, and 
        /// &lt;
        /// 0 to abort the scan.
        /// </remarks>
        public static git_result git_index_update_all(git_index index, string[] pathspec, git_index_matched_path_cb callback, IntPtr payload)
        {
            var pathspec__ = git_strarray.Allocate(pathspec);
            var __result__ = git_index_update_all__(index, in pathspec__, callback, payload);
            pathspec__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_update_all", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_update_all__(git_index index, in git_strarray pathspec, git_index_matched_path_cb callback, IntPtr payload);
        
        /// <summary>
        /// Find the first position of any entries which point to given
        /// path in the Git index.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>a zero-based position in the index if found; GIT_ENOTFOUND otherwise</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_find(ref size_t at_pos, git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Find the first position of any entries matching a prefix. To find the first position
        /// of a path inside a given folder, suffix the prefix with a '/'.
        /// </summary>
        /// <param name="at_pos">the address to which the position of the index entry is written (optional)</param>
        /// <param name="index">an existing index object</param>
        /// <param name="prefix">the prefix to search for</param>
        /// <returns>0 with valid value in at_pos; an error code otherwise</returns>
        public static git_result git_index_find_prefix(ref size_t at_pos, git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string prefix)
        {
            var __result__ = git_index_find_prefix__(ref at_pos, index, prefix).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_find_prefix", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_find_prefix__(ref size_t at_pos, git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string prefix);
        
        /// <summary>
        /// Add or update index entries to represent a conflict.  Any staged
        /// entries that exist at the given paths will be removed.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="ancestor_entry">the entry data for the ancestor of the conflict</param>
        /// <param name="our_entry">the entry data for our side of the merge conflict</param>
        /// <param name="their_entry">the entry data for their side of the merge conflict</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The entries are the entries from the tree included in the merge.  Any
        /// entry may be null to indicate that that file was not present in the
        /// trees during the merge.  For example, ancestor_entry may be NULL to
        /// indicate that a file was added in both branches and must be resolved.
        /// </remarks>
        public static git_result git_index_conflict_add(git_index index, in git_index_entry ancestor_entry, in git_index_entry our_entry, in git_index_entry their_entry)
        {
            var __result__ = git_index_conflict_add__(index, ancestor_entry, our_entry, their_entry).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_add", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_add__(git_index index, in git_index_entry ancestor_entry, in git_index_entry our_entry, in git_index_entry their_entry);
        
        /// <summary>
        /// Get the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="ancestor_out">Pointer to store the ancestor entry</param>
        /// <param name="our_out">Pointer to store the our entry</param>
        /// <param name="their_out">Pointer to store the their entry</param>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to search</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The entries are not modifiable and should not be freed.  Because the
        /// `git_index_entry` struct is a publicly defined struct, you should
        /// be able to make your own permanent copy of the data if necessary.
        /// </remarks>
        public static git_result git_index_conflict_get(out IntPtr ancestor_out, out IntPtr our_out, out IntPtr their_out, git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_index_conflict_get__(out ancestor_out, out our_out, out their_out, index, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_get", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_get__(out IntPtr ancestor_out, out IntPtr our_out, out IntPtr their_out, git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Removes the index entries that represent a conflict of a single file.
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <param name="path">path to remove conflicts for</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_index_conflict_remove(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_index_conflict_remove__(index, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_remove", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_remove__(git_index index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Remove all conflicts in the index (entries with a stage greater than 0).
        /// </summary>
        /// <param name="index">an existing index object</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_index_conflict_cleanup(git_index index)
        {
            var __result__ = git_index_conflict_cleanup__(index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_cleanup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_cleanup__(git_index index);
        
        /// <summary>
        /// Determine if the index contains entries representing file conflicts.
        /// </summary>
        /// <returns>1 if at least one conflict is found, 0 otherwise.</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_index_has_conflicts(git_index index);
        
        /// <summary>
        /// Create an iterator for the conflicts in the index.
        /// </summary>
        /// <param name="iterator_out">The newly created conflict iterator</param>
        /// <param name="index">The index to scan</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The index must not be modified while iterating; the results are undefined.
        /// </remarks>
        public static git_result git_index_conflict_iterator_new(out git_index_conflict_iterator iterator_out, git_index index)
        {
            var __result__ = git_index_conflict_iterator_new__(out iterator_out, index).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_iterator_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_iterator_new__(out git_index_conflict_iterator iterator_out, git_index index);
        
        /// <summary>
        /// Returns the current conflict (ancestor, ours and theirs entry) and
        /// advance the iterator internally to the next value.
        /// </summary>
        /// <param name="ancestor_out">Pointer to store the ancestor side of the conflict</param>
        /// <param name="our_out">Pointer to store our side of the conflict</param>
        /// <param name="their_out">Pointer to store their side of the conflict</param>
        /// <returns>0 (no error), GIT_ITEROVER (iteration is done) or an error code
        /// (negative value)</returns>
        public static git_result git_index_conflict_next(out IntPtr ancestor_out, out IntPtr our_out, out IntPtr their_out, git_index_conflict_iterator iterator)
        {
            var __result__ = git_index_conflict_next__(out ancestor_out, out our_out, out their_out, iterator).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_index_conflict_next", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_index_conflict_next__(out IntPtr ancestor_out, out IntPtr our_out, out IntPtr their_out, git_index_conflict_iterator iterator);
        
        /// <summary>
        /// Frees a `git_index_conflict_iterator`.
        /// </summary>
        /// <param name="iterator">pointer to the iterator</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_index_conflict_iterator_free(git_index_conflict_iterator iterator);
    }
}
