//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Basic type (loose or packed) of any Git object.
        /// </summary>
        public enum git_object_t : int
        {
            /// <summary>
            /// Object can be any of the following
            /// </summary>
            GIT_OBJECT_ANY = (int)-2,
            
            /// <summary>
            /// Object is invalid.
            /// </summary>
            GIT_OBJECT_INVALID = (int)-1,
            
            /// <summary>
            /// A commit object.
            /// </summary>
            GIT_OBJECT_COMMIT = (int)1,
            
            /// <summary>
            /// A tree (directory listing) object.
            /// </summary>
            GIT_OBJECT_TREE = (int)2,
            
            /// <summary>
            /// A file revision object.
            /// </summary>
            GIT_OBJECT_BLOB = (int)3,
            
            /// <summary>
            /// An annotated tag object.
            /// </summary>
            GIT_OBJECT_TAG = (int)4,
            
            /// <summary>
            /// A delta, base is given by an offset.
            /// </summary>
            GIT_OBJECT_OFS_DELTA = (int)6,
            
            /// <summary>
            /// A delta, base is given by object id.
            /// </summary>
            GIT_OBJECT_REF_DELTA = (int)7,
        }
        
        /// <summary>
        /// Object can be any of the following
        /// </summary>
        public const git_object_t GIT_OBJECT_ANY = git_object_t.GIT_OBJECT_ANY;
        
        /// <summary>
        /// Object is invalid.
        /// </summary>
        public const git_object_t GIT_OBJECT_INVALID = git_object_t.GIT_OBJECT_INVALID;
        
        /// <summary>
        /// A commit object.
        /// </summary>
        public const git_object_t GIT_OBJECT_COMMIT = git_object_t.GIT_OBJECT_COMMIT;
        
        /// <summary>
        /// A tree (directory listing) object.
        /// </summary>
        public const git_object_t GIT_OBJECT_TREE = git_object_t.GIT_OBJECT_TREE;
        
        /// <summary>
        /// A file revision object.
        /// </summary>
        public const git_object_t GIT_OBJECT_BLOB = git_object_t.GIT_OBJECT_BLOB;
        
        /// <summary>
        /// An annotated tag object.
        /// </summary>
        public const git_object_t GIT_OBJECT_TAG = git_object_t.GIT_OBJECT_TAG;
        
        /// <summary>
        /// A delta, base is given by an offset.
        /// </summary>
        public const git_object_t GIT_OBJECT_OFS_DELTA = git_object_t.GIT_OBJECT_OFS_DELTA;
        
        /// <summary>
        /// A delta, base is given by object id.
        /// </summary>
        public const git_object_t GIT_OBJECT_REF_DELTA = git_object_t.GIT_OBJECT_REF_DELTA;
        
        /// <summary>
        /// Basic type of any Git reference.
        /// </summary>
        public enum git_reference_t : int
        {
            /// <summary>
            /// Invalid reference
            /// </summary>
            GIT_REFERENCE_INVALID = (int)0,
            
            /// <summary>
            /// A reference that points at an object id
            /// </summary>
            GIT_REFERENCE_DIRECT = (int)1,
            
            /// <summary>
            /// A reference that points at another reference
            /// </summary>
            GIT_REFERENCE_SYMBOLIC = (int)2,
            
            GIT_REFERENCE_ALL = (int)GIT_REFERENCE_DIRECT | GIT_REFERENCE_SYMBOLIC,
        }
        
        /// <summary>
        /// Invalid reference
        /// </summary>
        public const git_reference_t GIT_REFERENCE_INVALID = git_reference_t.GIT_REFERENCE_INVALID;
        
        /// <summary>
        /// A reference that points at an object id
        /// </summary>
        public const git_reference_t GIT_REFERENCE_DIRECT = git_reference_t.GIT_REFERENCE_DIRECT;
        
        /// <summary>
        /// A reference that points at another reference
        /// </summary>
        public const git_reference_t GIT_REFERENCE_SYMBOLIC = git_reference_t.GIT_REFERENCE_SYMBOLIC;
        
        public const git_reference_t GIT_REFERENCE_ALL = git_reference_t.GIT_REFERENCE_ALL;
        
        /// <summary>
        /// Basic type of any Git branch.
        /// </summary>
        public enum git_branch_t : int
        {
            GIT_BRANCH_LOCAL = (int)1,
            
            GIT_BRANCH_REMOTE = (int)2,
            
            GIT_BRANCH_ALL = (int)GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE,
        }
        
        public const git_branch_t GIT_BRANCH_LOCAL = git_branch_t.GIT_BRANCH_LOCAL;
        
        public const git_branch_t GIT_BRANCH_REMOTE = git_branch_t.GIT_BRANCH_REMOTE;
        
        public const git_branch_t GIT_BRANCH_ALL = git_branch_t.GIT_BRANCH_ALL;
        
        /// <summary>
        /// Valid modes for index and tree entries.
        /// </summary>
        public enum git_filemode_t : int
        {
            GIT_FILEMODE_UNREADABLE = (int)0000000,
            
            GIT_FILEMODE_TREE = (int)0040000,
            
            GIT_FILEMODE_BLOB = (int)0100644,
            
            GIT_FILEMODE_BLOB_EXECUTABLE = (int)0100755,
            
            GIT_FILEMODE_LINK = (int)0120000,
            
            GIT_FILEMODE_COMMIT = (int)0160000,
        }
        
        public const git_filemode_t GIT_FILEMODE_UNREADABLE = git_filemode_t.GIT_FILEMODE_UNREADABLE;
        
        public const git_filemode_t GIT_FILEMODE_TREE = git_filemode_t.GIT_FILEMODE_TREE;
        
        public const git_filemode_t GIT_FILEMODE_BLOB = git_filemode_t.GIT_FILEMODE_BLOB;
        
        public const git_filemode_t GIT_FILEMODE_BLOB_EXECUTABLE = git_filemode_t.GIT_FILEMODE_BLOB_EXECUTABLE;
        
        public const git_filemode_t GIT_FILEMODE_LINK = git_filemode_t.GIT_FILEMODE_LINK;
        
        public const git_filemode_t GIT_FILEMODE_COMMIT = git_filemode_t.GIT_FILEMODE_COMMIT;
        
        /// <summary>
        /// Type of host certificate structure that is passed to the check callback
        /// </summary>
        public enum git_cert_t : int
        {
            /// <summary>
            /// No information about the certificate is available. This may
            /// happen when using curl.
            /// </summary>
            GIT_CERT_NONE,
            
            /// <summary>
            /// The `data` argument to the callback will be a pointer to
            /// the DER-encoded data.
            /// </summary>
            GIT_CERT_X509,
            
            /// <summary>
            /// The `data` argument to the callback will be a pointer to a
            /// `git_cert_hostkey` structure.
            /// </summary>
            GIT_CERT_HOSTKEY_LIBSSH2,
            
            /// <summary>
            /// The `data` argument to the callback will be a pointer to a
            /// `git_strarray` with `name:content` strings containing
            /// information about the certificate. This is used when using
            /// curl.
            /// </summary>
            GIT_CERT_STRARRAY,
        }
        
        /// <summary>
        /// No information about the certificate is available. This may
        /// happen when using curl.
        /// </summary>
        public const git_cert_t GIT_CERT_NONE = git_cert_t.GIT_CERT_NONE;
        
        /// <summary>
        /// The `data` argument to the callback will be a pointer to
        /// the DER-encoded data.
        /// </summary>
        public const git_cert_t GIT_CERT_X509 = git_cert_t.GIT_CERT_X509;
        
        /// <summary>
        /// The `data` argument to the callback will be a pointer to a
        /// `git_cert_hostkey` structure.
        /// </summary>
        public const git_cert_t GIT_CERT_HOSTKEY_LIBSSH2 = git_cert_t.GIT_CERT_HOSTKEY_LIBSSH2;
        
        /// <summary>
        /// The `data` argument to the callback will be a pointer to a
        /// `git_strarray` with `name:content` strings containing
        /// information about the certificate. This is used when using
        /// curl.
        /// </summary>
        public const git_cert_t GIT_CERT_STRARRAY = git_cert_t.GIT_CERT_STRARRAY;
        
        /// <summary>
        /// Submodule update values
        /// </summary>
        /// <remarks>
        /// These values represent settings for the `submodule.$name.update`
        /// configuration value which says how to handle `git submodule update` for
        /// this submodule.  The value is usually set in the ".gitmodules" file and
        /// copied to ".git/config" when the submodule is initialized.You can override this setting on a per-submodule basis with
        /// `git_submodule_set_update()` and write the changed value to disk using
        /// `git_submodule_save()`.  If you have overwritten the value, you can
        /// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.The values are:- GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
        /// updated, checkout the new detached HEAD to the submodule directory.
        /// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
        /// out branch onto the commit from the superproject.
        /// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
        /// superproject into the current checkout out branch of the submodule.
        /// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
        /// the commit in the superproject is updated.
        /// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
        /// when we don't want any particular update rule to be specified.
        /// </remarks>
        public enum git_submodule_update_t : int
        {
            GIT_SUBMODULE_UPDATE_CHECKOUT = (int)1,
            
            GIT_SUBMODULE_UPDATE_REBASE = (int)2,
            
            GIT_SUBMODULE_UPDATE_MERGE = (int)3,
            
            GIT_SUBMODULE_UPDATE_NONE = (int)4,
            
            GIT_SUBMODULE_UPDATE_DEFAULT = (int)0,
        }
        
        public const git_submodule_update_t GIT_SUBMODULE_UPDATE_CHECKOUT = git_submodule_update_t.GIT_SUBMODULE_UPDATE_CHECKOUT;
        
        public const git_submodule_update_t GIT_SUBMODULE_UPDATE_REBASE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_REBASE;
        
        public const git_submodule_update_t GIT_SUBMODULE_UPDATE_MERGE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_MERGE;
        
        public const git_submodule_update_t GIT_SUBMODULE_UPDATE_NONE = git_submodule_update_t.GIT_SUBMODULE_UPDATE_NONE;
        
        public const git_submodule_update_t GIT_SUBMODULE_UPDATE_DEFAULT = git_submodule_update_t.GIT_SUBMODULE_UPDATE_DEFAULT;
        
        /// <summary>
        /// Submodule ignore values
        /// </summary>
        /// <remarks>
        /// These values represent settings for the `submodule.$name.ignore`
        /// configuration value which says how deeply to look at the working
        /// directory when getting submodule status.You can override this value in memory on a per-submodule basis with
        /// `git_submodule_set_ignore()` and can write the changed value to disk
        /// with `git_submodule_save()`.  If you have overwritten the value, you
        /// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.The values are:- GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
        /// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
        /// untracked file, will mark the submodule as dirty.  Ignored files are
        /// still ignored, of course.
        /// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
        /// to tracked files, or the index or the HEAD commit will matter.
        /// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
        /// only considering changes if the HEAD of submodule has moved from the
        /// value in the superproject.
        /// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
        /// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
        /// when we don't want any particular ignore rule to be specified.
        /// </remarks>
        public enum git_submodule_ignore_t : int
        {
            /// <summary>
            /// use the submodule's configuration
            /// </summary>
            GIT_SUBMODULE_IGNORE_UNSPECIFIED = (int)-1,
            
            /// <summary>
            /// any change or untracked == dirty
            /// </summary>
            GIT_SUBMODULE_IGNORE_NONE = (int)1,
            
            /// <summary>
            /// dirty if tracked files change
            /// </summary>
            GIT_SUBMODULE_IGNORE_UNTRACKED = (int)2,
            
            /// <summary>
            /// only dirty if HEAD moved
            /// </summary>
            GIT_SUBMODULE_IGNORE_DIRTY = (int)3,
            
            /// <summary>
            /// never dirty
            /// </summary>
            GIT_SUBMODULE_IGNORE_ALL = (int)4,
        }
        
        /// <summary>
        /// use the submodule's configuration
        /// </summary>
        public const git_submodule_ignore_t GIT_SUBMODULE_IGNORE_UNSPECIFIED = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_UNSPECIFIED;
        
        /// <summary>
        /// any change or untracked == dirty
        /// </summary>
        public const git_submodule_ignore_t GIT_SUBMODULE_IGNORE_NONE = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_NONE;
        
        /// <summary>
        /// dirty if tracked files change
        /// </summary>
        public const git_submodule_ignore_t GIT_SUBMODULE_IGNORE_UNTRACKED = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_UNTRACKED;
        
        /// <summary>
        /// only dirty if HEAD moved
        /// </summary>
        public const git_submodule_ignore_t GIT_SUBMODULE_IGNORE_DIRTY = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_DIRTY;
        
        /// <summary>
        /// never dirty
        /// </summary>
        public const git_submodule_ignore_t GIT_SUBMODULE_IGNORE_ALL = git_submodule_ignore_t.GIT_SUBMODULE_IGNORE_ALL;
        
        /// <summary>
        /// Options for submodule recurse.
        /// </summary>
        /// <remarks>
        /// Represent the value of `submodule.$name.fetchRecurseSubmodules`* GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
        /// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
        /// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
        /// commit not already in local clone
        /// </remarks>
        public enum git_submodule_recurse_t : int
        {
            GIT_SUBMODULE_RECURSE_NO = (int)0,
            
            GIT_SUBMODULE_RECURSE_YES = (int)1,
            
            GIT_SUBMODULE_RECURSE_ONDEMAND = (int)2,
        }
        
        public const git_submodule_recurse_t GIT_SUBMODULE_RECURSE_NO = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_NO;
        
        public const git_submodule_recurse_t GIT_SUBMODULE_RECURSE_YES = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_YES;
        
        public const git_submodule_recurse_t GIT_SUBMODULE_RECURSE_ONDEMAND = git_submodule_recurse_t.GIT_SUBMODULE_RECURSE_ONDEMAND;
        
        /// <summary>
        /// An open object database handle.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_odb : IEquatable<git_odb>
        {
            private readonly IntPtr _handle;
            
            public git_odb(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_odb other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_odb other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_odb left, git_odb right) => left.Equals(right);
            
            public static bool operator !=(git_odb left, git_odb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A custom backend in an ODB
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_odb_backend : IEquatable<git_odb_backend>
        {
            private readonly IntPtr _handle;
            
            public git_odb_backend(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_odb_backend other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_odb_backend other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_odb_backend left, git_odb_backend right) => left.Equals(right);
            
            public static bool operator !=(git_odb_backend left, git_odb_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An object read from the ODB
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_odb_object : IEquatable<git_odb_object>
        {
            private readonly IntPtr _handle;
            
            public git_odb_object(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_odb_object other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_odb_object other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_odb_object left, git_odb_object right) => left.Equals(right);
            
            public static bool operator !=(git_odb_object left, git_odb_object right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_off_t : IEquatable<git_off_t>
        {
            public git_off_t(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(git_off_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is git_off_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(git_off_t from) => from.Value;
            
            public static implicit operator git_off_t(long from) => new git_off_t(from);
            
            public static bool operator ==(git_off_t left, git_off_t right) => left.Equals(right);
            
            public static bool operator !=(git_off_t left, git_off_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// This is passed as the first argument to the callback to allow the
        /// user to see the progress.
        /// </summary>
        /// <remarks>
        /// - total_objects: number of objects in the packfile being downloaded
        /// - indexed_objects: received objects that have been hashed
        /// - received_objects: objects which have been downloaded
        /// - local_objects: locally-available objects that have been injected
        /// in order to fix a thin pack.
        /// - received-bytes: size of the packfile received up to now
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_transfer_progress
        {
            public uint total_objects;
            
            public uint indexed_objects;
            
            public uint received_objects;
            
            public uint local_objects;
            
            public uint total_deltas;
            
            public uint indexed_deltas;
            
            public size_t received_bytes;
        }
        
        /// <summary>
        /// An open refs database handle.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_refdb : IEquatable<git_refdb>
        {
            private readonly IntPtr _handle;
            
            public git_refdb(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_refdb other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_refdb other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_refdb left, git_refdb right) => left.Equals(right);
            
            public static bool operator !=(git_refdb left, git_refdb right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A custom backend for refs
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_refdb_backend : IEquatable<git_refdb_backend>
        {
            private readonly IntPtr _handle;
            
            public git_refdb_backend(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_refdb_backend other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_refdb_backend other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_refdb_backend left, git_refdb_backend right) => left.Equals(right);
            
            public static bool operator !=(git_refdb_backend left, git_refdb_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of an existing git repository,
        /// including all its object contents
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_repository : IEquatable<git_repository>
        {
            private readonly IntPtr _handle;
            
            public git_repository(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_repository other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_repository other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_repository left, git_repository right) => left.Equals(right);
            
            public static bool operator !=(git_repository left, git_repository right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a working tree
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_worktree : IEquatable<git_worktree>
        {
            private readonly IntPtr _handle;
            
            public git_worktree(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_worktree other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_worktree other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_worktree left, git_worktree right) => left.Equals(right);
            
            public static bool operator !=(git_worktree left, git_worktree right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a generic object in a repository
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_object : IEquatable<git_object>
        {
            private readonly IntPtr _handle;
            
            public git_object(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_object other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_object other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_object left, git_object right) => left.Equals(right);
            
            public static bool operator !=(git_object left, git_object right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of an in-progress walk through the commits in a repo
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_revwalk : IEquatable<git_revwalk>
        {
            private readonly IntPtr _handle;
            
            public git_revwalk(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_revwalk other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_revwalk other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_revwalk left, git_revwalk right) => left.Equals(right);
            
            public static bool operator !=(git_revwalk left, git_revwalk right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Parsed representation of a tag object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_tag : IEquatable<git_tag>
        {
            private readonly IntPtr _handle;
            
            public git_tag(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_tag other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_tag other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_tag left, git_tag right) => left.Equals(right);
            
            public static bool operator !=(git_tag left, git_tag right) => !left.Equals(right);
        }
        
        /// <summary>
        /// In-memory representation of a blob object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_blob : IEquatable<git_blob>
        {
            private readonly IntPtr _handle;
            
            public git_blob(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_blob other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_blob other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_blob left, git_blob right) => left.Equals(right);
            
            public static bool operator !=(git_blob left, git_blob right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Parsed representation of a commit object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_commit : IEquatable<git_commit>
        {
            private readonly IntPtr _handle;
            
            public git_commit(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_commit other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_commit other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_commit left, git_commit right) => left.Equals(right);
            
            public static bool operator !=(git_commit left, git_commit right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of each one of the entries in a tree object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_tree_entry : IEquatable<git_tree_entry>
        {
            private readonly IntPtr _handle;
            
            public git_tree_entry(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_tree_entry other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_tree_entry other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_tree_entry left, git_tree_entry right) => left.Equals(right);
            
            public static bool operator !=(git_tree_entry left, git_tree_entry right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a tree object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_tree : IEquatable<git_tree>
        {
            private readonly IntPtr _handle;
            
            public git_tree(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_tree other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_tree other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_tree left, git_tree right) => left.Equals(right);
            
            public static bool operator !=(git_tree left, git_tree right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Constructor for in-memory trees
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_treebuilder : IEquatable<git_treebuilder>
        {
            private readonly IntPtr _handle;
            
            public git_treebuilder(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_treebuilder other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_treebuilder other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_treebuilder left, git_treebuilder right) => left.Equals(right);
            
            public static bool operator !=(git_treebuilder left, git_treebuilder right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Memory representation of an index file.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_index : IEquatable<git_index>
        {
            private readonly IntPtr _handle;
            
            public git_index(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_index other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_index other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_index left, git_index right) => left.Equals(right);
            
            public static bool operator !=(git_index left, git_index right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An iterator for entries in the index.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_index_iterator : IEquatable<git_index_iterator>
        {
            private readonly IntPtr _handle;
            
            public git_index_iterator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_index_iterator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_index_iterator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_index_iterator left, git_index_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_index_iterator left, git_index_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An iterator for conflicts in the index.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_index_conflict_iterator : IEquatable<git_index_conflict_iterator>
        {
            private readonly IntPtr _handle;
            
            public git_index_conflict_iterator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_index_conflict_iterator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_index_conflict_iterator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_index_conflict_iterator left, git_index_conflict_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_index_conflict_iterator left, git_index_conflict_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Memory representation of a set of config files
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_config : IEquatable<git_config>
        {
            private readonly IntPtr _handle;
            
            public git_config(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_config other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_config other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_config left, git_config right) => left.Equals(right);
            
            public static bool operator !=(git_config left, git_config right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Interface to access a configuration file
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_config_backend : IEquatable<git_config_backend>
        {
            private readonly IntPtr _handle;
            
            public git_config_backend(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_config_backend other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_config_backend other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_config_backend left, git_config_backend right) => left.Equals(right);
            
            public static bool operator !=(git_config_backend left, git_config_backend right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a reference log entry
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_reflog_entry : IEquatable<git_reflog_entry>
        {
            private readonly IntPtr _handle;
            
            public git_reflog_entry(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_reflog_entry other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_reflog_entry other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_reflog_entry left, git_reflog_entry right) => left.Equals(right);
            
            public static bool operator !=(git_reflog_entry left, git_reflog_entry right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a reference log
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_reflog : IEquatable<git_reflog>
        {
            private readonly IntPtr _handle;
            
            public git_reflog(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_reflog other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_reflog other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_reflog left, git_reflog right) => left.Equals(right);
            
            public static bool operator !=(git_reflog left, git_reflog right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a git note
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_note : IEquatable<git_note>
        {
            private readonly IntPtr _handle;
            
            public git_note(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_note other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_note other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_note left, git_note right) => left.Equals(right);
            
            public static bool operator !=(git_note left, git_note right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a git packbuilder
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_packbuilder : IEquatable<git_packbuilder>
        {
            private readonly IntPtr _handle;
            
            public git_packbuilder(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_packbuilder other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_packbuilder other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_packbuilder left, git_packbuilder right) => left.Equals(right);
            
            public static bool operator !=(git_packbuilder left, git_packbuilder right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Time in a signature
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_time
        {
            /// <summary>
            /// time in seconds from epoch
            /// </summary>
            public git_time_t time;
            
            /// <summary>
            /// timezone offset, in minutes
            /// </summary>
            public int offset;
            
            /// <summary>
            /// indicator for questionable '-0000' offsets in signature
            /// </summary>
            public sbyte sign;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_time_t : IEquatable<git_time_t>
        {
            public git_time_t(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(git_time_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is git_time_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(git_time_t from) => from.Value;
            
            public static implicit operator git_time_t(long from) => new git_time_t(from);
            
            public static bool operator ==(git_time_t left, git_time_t right) => left.Equals(right);
            
            public static bool operator !=(git_time_t left, git_time_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// An action signature (e.g. for committers, taggers, etc)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_signature
        {
            /// <summary>
            /// full name of the author
            /// </summary>
            public IntPtr name;
            
            /// <summary>
            /// email of the author
            /// </summary>
            public IntPtr email;
            
            /// <summary>
            /// time when the action happened
            /// </summary>
            public git_time when;
        }
        
        /// <summary>
        /// In-memory representation of a reference.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_reference : IEquatable<git_reference>
        {
            private readonly IntPtr _handle;
            
            public git_reference(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_reference other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_reference other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_reference left, git_reference right) => left.Equals(right);
            
            public static bool operator !=(git_reference left, git_reference right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Iterator for references
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_reference_iterator : IEquatable<git_reference_iterator>
        {
            private readonly IntPtr _handle;
            
            public git_reference_iterator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_reference_iterator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_reference_iterator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_reference_iterator left, git_reference_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_reference_iterator left, git_reference_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Transactional interface to references
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_transaction : IEquatable<git_transaction>
        {
            private readonly IntPtr _handle;
            
            public git_transaction(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_transaction other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_transaction other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_transaction left, git_transaction right) => left.Equals(right);
            
            public static bool operator !=(git_transaction left, git_transaction right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Annotated commits, the input to merge and rebase.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_annotated_commit : IEquatable<git_annotated_commit>
        {
            private readonly IntPtr _handle;
            
            public git_annotated_commit(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_annotated_commit other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_annotated_commit other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_annotated_commit left, git_annotated_commit right) => left.Equals(right);
            
            public static bool operator !=(git_annotated_commit left, git_annotated_commit right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a status collection
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_status_list : IEquatable<git_status_list>
        {
            private readonly IntPtr _handle;
            
            public git_status_list(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_status_list other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_status_list other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_status_list left, git_status_list right) => left.Equals(right);
            
            public static bool operator !=(git_status_list left, git_status_list right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Representation of a rebase
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_rebase : IEquatable<git_rebase>
        {
            private readonly IntPtr _handle;
            
            public git_rebase(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_rebase other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_rebase other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_rebase left, git_rebase right) => left.Equals(right);
            
            public static bool operator !=(git_rebase left, git_rebase right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A refspec specifies the mapping between remote and local reference
        /// names when fetch or pushing.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_refspec : IEquatable<git_refspec>
        {
            private readonly IntPtr _handle;
            
            public git_refspec(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_refspec other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_refspec other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_refspec left, git_refspec right) => left.Equals(right);
            
            public static bool operator !=(git_refspec left, git_refspec right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Git's idea of a remote repository. A remote can be anonymous (in
        /// which case it does not have backing configuration entires).
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_remote : IEquatable<git_remote>
        {
            private readonly IntPtr _handle;
            
            public git_remote(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_remote other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_remote other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_remote left, git_remote right) => left.Equals(right);
            
            public static bool operator !=(git_remote left, git_remote right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Interface which represents a transport to communicate with a
        /// remote.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_transport : IEquatable<git_transport>
        {
            private readonly IntPtr _handle;
            
            public git_transport(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_transport other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_transport other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_transport left, git_transport right) => left.Equals(right);
            
            public static bool operator !=(git_transport left, git_transport right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Preparation for a push operation. Can be used to configure what to
        /// push and the level of parallelism of the packfile builder.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_push : IEquatable<git_push>
        {
            private readonly IntPtr _handle;
            
            public git_push(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_push other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_push other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_push left, git_push right) => left.Equals(right);
            
            public static bool operator !=(git_push left, git_push right) => !left.Equals(right);
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_transport_message_cb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string str, int len, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_transport_certificate_check_cb(ref git_cert cert, int valid, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string host, IntPtr payload);
        
        /// <summary>
        /// Parent type for `git_cert_hostkey` and `git_cert_x509`.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_cert
        {
            /// <summary>
            /// Type of certificate. A `GIT_CERT_` value.
            /// </summary>
            public git_cert_t cert_type;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_transfer_progress_cb(in git_transfer_progress stats, IntPtr payload);
        
        /// <summary>
        /// Opaque structure representing a submodule.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_submodule : IEquatable<git_submodule>
        {
            private readonly IntPtr _handle;
            
            public git_submodule(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_submodule other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_submodule other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_submodule left, git_submodule right) => left.Equals(right);
            
            public static bool operator !=(git_submodule left, git_submodule right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A type to write in a streaming fashion, for example, for filters.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_writestream
        {
            public write_delegate write;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate int write_delegate(ref git_writestream stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string buffer, size_t len);
            
            public close_delegate close;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate int close_delegate(ref git_writestream stream);
            
            public free_delegate free;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void free_delegate(ref git_writestream stream);
        }
        
        /// <summary>
        /// Representation of .mailmap file state.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_mailmap : IEquatable<git_mailmap>
        {
            private readonly IntPtr _handle;
            
            public git_mailmap(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_mailmap other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_mailmap other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_mailmap left, git_mailmap right) => left.Equals(right);
            
            public static bool operator !=(git_mailmap left, git_mailmap right) => !left.Equals(right);
        }
    }
}
