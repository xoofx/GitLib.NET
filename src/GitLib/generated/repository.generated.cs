//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Option flags for `git_repository_open_ext`.
        /// </summary>
        [Flags]
        public enum git_repository_open_flag_t : int
        {
            /// <summary>
            /// Only open the repository if it can be immediately found in the
            /// start_path. Do not walk up from the start_path looking at parent
            /// directories.
            /// </summary>
            GIT_REPOSITORY_OPEN_NO_SEARCH = (int)(1 << 0),
            
            /// <summary>
            /// Unless this flag is set, open will not continue searching across
            /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
            /// system call).  For example, searching in a user's home directory at
            /// "/home/user/source/" will not return "/.git/" as the found repo if
            /// "/" is a different filesystem than "/home".
            /// </summary>
            GIT_REPOSITORY_OPEN_CROSS_FS = (int)(1 << 1),
            
            /// <summary>
            /// Open repository as a bare repo regardless of core.bare config, and
            /// defer loading config file for faster setup.
            /// Unlike `git_repository_open_bare`, this can follow gitlinks.
            /// </summary>
            GIT_REPOSITORY_OPEN_BARE = (int)(1 << 2),
            
            /// <summary>
            /// Do not check for a repository by appending /.git to the start_path;
            /// only open the repository if start_path itself points to the git
            /// directory.
            /// </summary>
            GIT_REPOSITORY_OPEN_NO_DOTGIT = (int)(1 << 3),
            
            /// <summary>
            /// Find and open a git repository, respecting the environment variables
            /// used by the git command-line tools.
            /// If set, `git_repository_open_ext` will ignore the other flags and
            /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
            /// `GIT_DIR` or search from the current directory.
            /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
            /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
            /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
            /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
            /// In the future, this flag will also cause `git_repository_open_ext`
            /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
            /// `git_repository_open_ext` with this flag will error out if either
            /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
            /// </summary>
            GIT_REPOSITORY_OPEN_FROM_ENV = (int)(1 << 4),
        }
        
        /// <summary>
        /// Only open the repository if it can be immediately found in the
        /// start_path. Do not walk up from the start_path looking at parent
        /// directories.
        /// </summary>
        public const git_repository_open_flag_t GIT_REPOSITORY_OPEN_NO_SEARCH = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_NO_SEARCH;
        
        /// <summary>
        /// Unless this flag is set, open will not continue searching across
        /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
        /// system call).  For example, searching in a user's home directory at
        /// "/home/user/source/" will not return "/.git/" as the found repo if
        /// "/" is a different filesystem than "/home".
        /// </summary>
        public const git_repository_open_flag_t GIT_REPOSITORY_OPEN_CROSS_FS = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_CROSS_FS;
        
        /// <summary>
        /// Open repository as a bare repo regardless of core.bare config, and
        /// defer loading config file for faster setup.
        /// Unlike `git_repository_open_bare`, this can follow gitlinks.
        /// </summary>
        public const git_repository_open_flag_t GIT_REPOSITORY_OPEN_BARE = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_BARE;
        
        /// <summary>
        /// Do not check for a repository by appending /.git to the start_path;
        /// only open the repository if start_path itself points to the git
        /// directory.
        /// </summary>
        public const git_repository_open_flag_t GIT_REPOSITORY_OPEN_NO_DOTGIT = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_NO_DOTGIT;
        
        /// <summary>
        /// Find and open a git repository, respecting the environment variables
        /// used by the git command-line tools.
        /// If set, `git_repository_open_ext` will ignore the other flags and
        /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
        /// `GIT_DIR` or search from the current directory.
        /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
        /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
        /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
        /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
        /// In the future, this flag will also cause `git_repository_open_ext`
        /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
        /// `git_repository_open_ext` with this flag will error out if either
        /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
        /// </summary>
        public const git_repository_open_flag_t GIT_REPOSITORY_OPEN_FROM_ENV = git_repository_open_flag_t.GIT_REPOSITORY_OPEN_FROM_ENV;
        
        /// <summary>
        /// Option flags for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// These flags configure extra behaviors to `git_repository_init_ext`.
        /// In every case, the default behavior is the zero value (i.e. flag is
        /// not set).  Just OR the flag values together for the `flags` parameter
        /// when initializing a new repo.  Details of individual values are:* BARE   - Create a bare repository with no working directory.
        /// * NO_REINIT - Return an GIT_EEXISTS error if the repo_path appears to
        /// already be an git repository.
        /// * NO_DOTGIT_DIR - Normally a "/.git/" will be appended to the repo
        /// path for non-bare repos (if it is not already there), but
        /// passing this flag prevents that behavior.
        /// * MKDIR  - Make the repo_path (and workdir_path) as needed.  Init is
        /// always willing to create the ".git" directory even without this
        /// flag.  This flag tells init to create the trailing component of
        /// the repo and workdir paths as needed.
        /// * MKPATH - Recursively make all components of the repo and workdir
        /// paths as necessary.
        /// * EXTERNAL_TEMPLATE - libgit2 normally uses internal templates to
        /// initialize a new repo.  This flags enables external templates,
        /// looking the "template_path" from the options if set, or the
        /// `init.templatedir` global config if not, or falling back on
        /// "/usr/share/git-core/templates" if it exists.
        /// * GIT_REPOSITORY_INIT_RELATIVE_GITLINK - If an alternate workdir is
        /// specified, use relative paths for the gitdir and core.worktree.
        /// </remarks>
        [Flags]
        public enum git_repository_init_flag_t : int
        {
            GIT_REPOSITORY_INIT_BARE = (int)(1u<<0),
            
            GIT_REPOSITORY_INIT_NO_REINIT = (int)(1u<<1),
            
            GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = (int)(1u<<2),
            
            GIT_REPOSITORY_INIT_MKDIR = (int)(1u<<3),
            
            GIT_REPOSITORY_INIT_MKPATH = (int)(1u<<4),
            
            GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = (int)(1u<<5),
            
            GIT_REPOSITORY_INIT_RELATIVE_GITLINK = (int)(1u<<6),
        }
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_BARE = git_repository_init_flag_t.GIT_REPOSITORY_INIT_BARE;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_NO_REINIT = git_repository_init_flag_t.GIT_REPOSITORY_INIT_NO_REINIT;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = git_repository_init_flag_t.GIT_REPOSITORY_INIT_NO_DOTGIT_DIR;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_MKDIR = git_repository_init_flag_t.GIT_REPOSITORY_INIT_MKDIR;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_MKPATH = git_repository_init_flag_t.GIT_REPOSITORY_INIT_MKPATH;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = git_repository_init_flag_t.GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE;
        
        public const git_repository_init_flag_t GIT_REPOSITORY_INIT_RELATIVE_GITLINK = git_repository_init_flag_t.GIT_REPOSITORY_INIT_RELATIVE_GITLINK;
        
        /// <summary>
        /// Mode options for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// Set the mode field of the `git_repository_init_options` structure
        /// either to the custom mode that you would like, or to one of the
        /// following modes:* SHARED_UMASK - Use permissions configured by umask - the default.
        /// * SHARED_GROUP - Use "--shared=group" behavior, chmod'ing the new repo
        /// to be group writable and "g+sx" for sticky group assignment.
        /// * SHARED_ALL - Use "--shared=all" behavior, adding world readability.
        /// * Anything else - Set to custom value.
        /// </remarks>
        public enum git_repository_init_mode_t : int
        {
            GIT_REPOSITORY_INIT_SHARED_UMASK = (int)0,
            
            GIT_REPOSITORY_INIT_SHARED_GROUP = (int)0002775,
            
            GIT_REPOSITORY_INIT_SHARED_ALL = (int)0002777,
        }
        
        public const git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_UMASK = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_UMASK;
        
        public const git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_GROUP = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_GROUP;
        
        public const git_repository_init_mode_t GIT_REPOSITORY_INIT_SHARED_ALL = git_repository_init_mode_t.GIT_REPOSITORY_INIT_SHARED_ALL;
        
        /// <summary>
        /// List of items which belong to the git repository layout
        /// </summary>
        public enum git_repository_item_t : int
        {
            GIT_REPOSITORY_ITEM_GITDIR,
            
            GIT_REPOSITORY_ITEM_WORKDIR,
            
            GIT_REPOSITORY_ITEM_COMMONDIR,
            
            GIT_REPOSITORY_ITEM_INDEX,
            
            GIT_REPOSITORY_ITEM_OBJECTS,
            
            GIT_REPOSITORY_ITEM_REFS,
            
            GIT_REPOSITORY_ITEM_PACKED_REFS,
            
            GIT_REPOSITORY_ITEM_REMOTES,
            
            GIT_REPOSITORY_ITEM_CONFIG,
            
            GIT_REPOSITORY_ITEM_INFO,
            
            GIT_REPOSITORY_ITEM_HOOKS,
            
            GIT_REPOSITORY_ITEM_LOGS,
            
            GIT_REPOSITORY_ITEM_MODULES,
            
            GIT_REPOSITORY_ITEM_WORKTREES,
        }
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_GITDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_GITDIR;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_WORKDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_WORKDIR;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_COMMONDIR = git_repository_item_t.GIT_REPOSITORY_ITEM_COMMONDIR;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_INDEX = git_repository_item_t.GIT_REPOSITORY_ITEM_INDEX;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_OBJECTS = git_repository_item_t.GIT_REPOSITORY_ITEM_OBJECTS;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_REFS = git_repository_item_t.GIT_REPOSITORY_ITEM_REFS;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_PACKED_REFS = git_repository_item_t.GIT_REPOSITORY_ITEM_PACKED_REFS;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_REMOTES = git_repository_item_t.GIT_REPOSITORY_ITEM_REMOTES;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_CONFIG = git_repository_item_t.GIT_REPOSITORY_ITEM_CONFIG;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_INFO = git_repository_item_t.GIT_REPOSITORY_ITEM_INFO;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_HOOKS = git_repository_item_t.GIT_REPOSITORY_ITEM_HOOKS;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_LOGS = git_repository_item_t.GIT_REPOSITORY_ITEM_LOGS;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_MODULES = git_repository_item_t.GIT_REPOSITORY_ITEM_MODULES;
        
        public const git_repository_item_t GIT_REPOSITORY_ITEM_WORKTREES = git_repository_item_t.GIT_REPOSITORY_ITEM_WORKTREES;
        
        /// <summary>
        /// Repository state
        /// </summary>
        /// <remarks>
        /// These values represent possible states for the repository to be in,
        /// based on the current operation which is ongoing.
        /// </remarks>
        public enum git_repository_state_t : int
        {
            GIT_REPOSITORY_STATE_NONE,
            
            GIT_REPOSITORY_STATE_MERGE,
            
            GIT_REPOSITORY_STATE_REVERT,
            
            GIT_REPOSITORY_STATE_REVERT_SEQUENCE,
            
            GIT_REPOSITORY_STATE_CHERRYPICK,
            
            GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE,
            
            GIT_REPOSITORY_STATE_BISECT,
            
            GIT_REPOSITORY_STATE_REBASE,
            
            GIT_REPOSITORY_STATE_REBASE_INTERACTIVE,
            
            GIT_REPOSITORY_STATE_REBASE_MERGE,
            
            GIT_REPOSITORY_STATE_APPLY_MAILBOX,
            
            GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE,
        }
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_NONE = git_repository_state_t.GIT_REPOSITORY_STATE_NONE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_MERGE = git_repository_state_t.GIT_REPOSITORY_STATE_MERGE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_REVERT = git_repository_state_t.GIT_REPOSITORY_STATE_REVERT;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_REVERT_SEQUENCE = git_repository_state_t.GIT_REPOSITORY_STATE_REVERT_SEQUENCE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_CHERRYPICK = git_repository_state_t.GIT_REPOSITORY_STATE_CHERRYPICK;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = git_repository_state_t.GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_BISECT = git_repository_state_t.GIT_REPOSITORY_STATE_BISECT;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_REBASE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE_INTERACTIVE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_REBASE_MERGE = git_repository_state_t.GIT_REPOSITORY_STATE_REBASE_MERGE;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_APPLY_MAILBOX = git_repository_state_t.GIT_REPOSITORY_STATE_APPLY_MAILBOX;
        
        public const git_repository_state_t GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = git_repository_state_t.GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE;
        
        /// <summary>
        /// Extended options structure for `git_repository_init_ext`.
        /// </summary>
        /// <remarks>
        /// This contains extra options for `git_repository_init_ext` that enable
        /// additional initialization features.  The fields are:* flags - Combination of GIT_REPOSITORY_INIT flags above.
        /// * mode  - Set to one of the standard GIT_REPOSITORY_INIT_SHARED_...
        /// constants above, or to a custom value that you would like.
        /// * workdir_path - The path to the working dir or NULL for default (i.e.
        /// repo_path parent on non-bare repos).  IF THIS IS RELATIVE PATH,
        /// IT WILL BE EVALUATED RELATIVE TO THE REPO_PATH.  If this is not
        /// the "natural" working directory, a .git gitlink file will be
        /// created here linking to the repo_path.
        /// * description - If set, this will be used to initialize the "description"
        /// file in the repository, instead of using the template content.
        /// * template_path - When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set,
        /// this contains the path to use for the template directory.  If
        /// this is NULL, the config or default directory options will be
        /// used instead.
        /// * initial_head - The name of the head to point HEAD at.  If NULL, then
        /// this will be treated as "master" and the HEAD ref will be set
        /// to "refs/heads/master".  If this begins with "refs/" it will be
        /// used verbatim; otherwise "refs/heads/" will be prefixed.
        /// * origin_url - If this is non-NULL, then after the rest of the
        /// repository initialization is completed, an "origin" remote
        /// will be added pointing to this URL.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_repository_init_options
        {
            public uint version;
            
            public git_repository_init_flag_t flags;
            
            public git_repository_init_mode_t mode;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string workdir_path;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string description;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string template_path;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string initial_head;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string origin_url;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_repository_fetchhead_foreach_cb([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))] string ref_name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))] string remote_url, in git_oid oid, uint is_merge, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_repository_mergehead_foreach_cb(in git_oid oid, IntPtr payload);
        
        /// <summary>
        /// Open a git repository.
        /// </summary>
        /// <param name="out">pointer to the repo which will be opened</param>
        /// <param name="path">the path to the repository</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The 'path' argument must point to either a git repository
        /// folder, or an existing work dir.The method will automatically detect if 'path' is a normal
        /// or bare repository or fail is 'path' is neither.
        /// </remarks>
        public static git_result git_repository_open(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_repository_open__(out @out, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_open", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_open__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Open working tree as a repository
        /// </summary>
        /// <param name="out">Output pointer containing opened repository</param>
        /// <param name="wt">Working tree to open</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Open the working directory of the working tree as a normal
        /// repository that can then be worked on.
        /// </remarks>
        public static git_result git_repository_open_from_worktree(out git_repository @out, git_worktree wt)
        {
            var __result__ = git_repository_open_from_worktree__(out @out, wt).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_open_from_worktree", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_open_from_worktree__(out git_repository @out, git_worktree wt);
        
        /// <summary>
        /// Create a "fake" repository to wrap an object database
        /// </summary>
        /// <param name="out">pointer to the repo</param>
        /// <param name="odb">the object database to wrap</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Create a repository object to wrap an object database to be used
        /// with the API when all you have is an object database. This doesn't
        /// have any paths associated with it, so use with care.
        /// </remarks>
        public static git_result git_repository_wrap_odb(out git_repository @out, git_odb odb)
        {
            var __result__ = git_repository_wrap_odb__(out @out, odb).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_wrap_odb", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_wrap_odb__(out git_repository @out, git_odb odb);
        
        /// <summary>
        /// Look for a git repository and copy its path in the given buffer.
        /// The lookup start from base_path and walk across parent directories
        /// if nothing has been found. The lookup ends when the first repository
        /// is found, or when reaching a directory referenced in ceiling_dirs
        /// or when the filesystem changes (in case across_fs is true).
        /// </summary>
        /// <param name="out">A pointer to a user-allocated git_buf which will contain
        /// the found path.</param>
        /// <param name="start_path">The base path where the lookup starts.</param>
        /// <param name="across_fs">If true, then the lookup will not stop when a
        /// filesystem device change is detected while exploring parent directories.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR separated list of
        /// absolute symbolic link free paths. The lookup will stop when any
        /// of this paths is reached. Note that the lookup always performs on
        /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
        /// might be NULL (which is equivalent to an empty string)</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The method will automatically detect if the repository is bare
        /// (if there is a repository).
        /// </remarks>
        public static git_result git_repository_discover(out git_buf @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string start_path, [MarshalAs(UnmanagedType.Bool)] bool across_fs, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string ceiling_dirs)
        {
            var __result__ = git_repository_discover__(out @out, start_path, across_fs, ceiling_dirs).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_discover", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_discover__(out git_buf @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string start_path, [MarshalAs(UnmanagedType.Bool)] bool across_fs, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string ceiling_dirs);
        
        /// <summary>
        /// Find and open a repository with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.  This can
        /// actually be NULL if you only want to use the error code to
        /// see if a repo at this path could be opened.</param>
        /// <param name="path">Path to open as git repository.  If the flags
        /// permit "searching", then this can be a path to a subdirectory
        /// inside the working directory of the repository. May be NULL if
        /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.</param>
        /// <param name="flags">A combination of the GIT_REPOSITORY_OPEN flags above.</param>
        /// <param name="ceiling_dirs">A GIT_PATH_LIST_SEPARATOR delimited list of path
        /// prefixes at which the search for a containing repository should
        /// terminate.</param>
        /// <returns>0 on success, GIT_ENOTFOUND if no repository could be found,
        /// or -1 if there was a repository but open failed for some reason
        /// (such as repo corruption or system errors).</returns>
        public static git_result git_repository_open_ext(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_repository_open_flag_t flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string ceiling_dirs)
        {
            var __result__ = git_repository_open_ext__(out @out, path, flags, ceiling_dirs).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_open_ext", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_open_ext__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_repository_open_flag_t flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string ceiling_dirs);
        
        /// <summary>
        /// Open a bare repository on the serverside.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be opened.</param>
        /// <param name="bare_path">Direct path to the bare repository</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// This is a fast open for bare repositories that will come in handy
        /// if you're e.g. hosting git repositories and need to access them
        /// efficiently
        /// </remarks>
        public static git_result git_repository_open_bare(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string bare_path)
        {
            var __result__ = git_repository_open_bare__(out @out, bare_path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_open_bare", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_open_bare__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string bare_path);
        
        /// <summary>
        /// Free a previously allocated repository
        /// </summary>
        /// <param name="repo">repository handle to close. If NULL nothing occurs.</param>
        /// <remarks>
        /// Note that after a repository is free'd, all the objects it has spawned
        /// will still exist until they are manually closed by the user
        /// with `git_object_free`, but accessing any of the attributes of
        /// an object without a backing repository will result in undefined
        /// behavior
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_repository_free(git_repository repo);
        
        /// <summary>
        /// Creates a new Git repository in the given folder.
        /// </summary>
        /// <param name="out">pointer to the repo which will be created or reinitialized</param>
        /// <param name="path">the path to the repository</param>
        /// <param name="is_bare">if true, a Git repository without a working directory is
        /// created at the pointed path. If false, provided path will be
        /// considered as the working directory into which the .git directory
        /// will be created.</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// TODO:
        /// - Reinit the repository
        /// </remarks>
        public static git_result git_repository_init(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, [MarshalAs(UnmanagedType.Bool)] bool is_bare)
        {
            var __result__ = git_repository_init__(out @out, path, is_bare).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_init", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_init__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, [MarshalAs(UnmanagedType.Bool)] bool is_bare);
        
        /// <summary>
        /// Initialize git_repository_init_options structure
        /// </summary>
        /// <param name="opts">The `git_repository_init_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_repository_init_options` with default values. Equivalent to
        /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_repository_init_init_options(ref git_repository_init_options opts, uint version = GIT_REPOSITORY_INIT_OPTIONS_VERSION)
        {
            var __result__ = git_repository_init_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_init_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_init_init_options__(ref git_repository_init_options opts, uint version = GIT_REPOSITORY_INIT_OPTIONS_VERSION);
        
        /// <summary>
        /// Create a new Git repository in the given folder with extended controls.
        /// </summary>
        /// <param name="out">Pointer to the repo which will be created or reinitialized.</param>
        /// <param name="repo_path">The path to the repository.</param>
        /// <param name="opts">Pointer to git_repository_init_options struct.</param>
        /// <returns>0 or an error code on failure.</returns>
        /// <remarks>
        /// This will initialize a new git repository (creating the repo_path
        /// if requested by flags) and working directory as needed.  It will
        /// auto-detect the case sensitivity of the file system and if the
        /// file system supports file mode bits correctly.
        /// </remarks>
        public static git_result git_repository_init_ext(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string repo_path, ref git_repository_init_options opts)
        {
            var __result__ = git_repository_init_ext__(out @out, repo_path, ref opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_init_ext", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_init_ext__(out git_repository @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string repo_path, ref git_repository_init_options opts);
        
        /// <summary>
        /// Retrieve and resolve the reference pointed at by HEAD.
        /// </summary>
        /// <param name="out">pointer to the reference which will be retrieved</param>
        /// <param name="repo">a repository object</param>
        /// <returns>0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
        /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise</returns>
        /// <remarks>
        /// The returned `git_reference` will be owned by caller and
        /// `git_reference_free()` must be called when done with it to release the
        /// allocated memory and prevent a leak.
        /// </remarks>
        public static git_result git_repository_head(out git_reference @out, git_repository repo)
        {
            var __result__ = git_repository_head__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_head", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_head__(out git_reference @out, git_repository repo);
        
        /// <summary>
        /// Retrieve the referenced HEAD for the worktree
        /// </summary>
        /// <param name="out">pointer to the reference which will be retrieved</param>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>0 when successful, error-code otherwise</returns>
        public static git_result git_repository_head_for_worktree(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_repository_head_for_worktree__(out @out, repo, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_head_for_worktree", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_head_for_worktree__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Check if a repository's HEAD is detached
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>1 if HEAD is detached, 0 if it's not; error code if there
        /// was an error.</returns>
        /// <remarks>
        /// A repository's HEAD is detached when it points directly to a commit
        /// instead of a branch.
        /// </remarks>
        public static git_result_bool git_repository_head_detached(git_repository repo)
        {
            var __result__ = git_repository_head_detached__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_head_detached", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result_bool git_repository_head_detached__(git_repository repo);
        
        /// <summary>
        /// Check if a worktree's HEAD is detached
        /// </summary>
        /// <param name="repo">a repository object</param>
        /// <param name="name">name of the worktree to retrieve HEAD for</param>
        /// <returns>1 if HEAD is detached, 0 if its not; error code if
        /// there was an error</returns>
        /// <remarks>
        /// A worktree's HEAD is detached when it points directly to a
        /// commit instead of a branch.
        /// </remarks>
        public static git_result_bool git_repository_head_detached_for_worktree(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_repository_head_detached_for_worktree__(repo, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_head_detached_for_worktree", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result_bool git_repository_head_detached_for_worktree__(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Check if the current branch is unborn
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>1 if the current branch is unborn, 0 if it's not; error
        /// code if there was an error</returns>
        /// <remarks>
        /// An unborn branch is one named from HEAD but which doesn't exist in
        /// the refs namespace, because it doesn't have any commit to point to.
        /// </remarks>
        public static git_result_bool git_repository_head_unborn(git_repository repo)
        {
            var __result__ = git_repository_head_unborn__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_head_unborn", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result_bool git_repository_head_unborn__(git_repository repo);
        
        /// <summary>
        /// Check if a repository is empty
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>1 if the repository is empty, 0 if it isn't, error code
        /// if the repository is corrupted</returns>
        /// <remarks>
        /// An empty repository has just been initialized and contains no references
        /// apart from HEAD, which must be pointing to the unborn master branch.
        /// </remarks>
        public static git_result_bool git_repository_is_empty(git_repository repo)
        {
            var __result__ = git_repository_is_empty__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_is_empty", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result_bool git_repository_is_empty__(git_repository repo);
        
        /// <summary>
        /// Get the location of a specific repository file or directory
        /// </summary>
        /// <param name="out">Buffer to store the path at</param>
        /// <param name="repo">Repository to get path for</param>
        /// <param name="item">The repository item for which to retrieve the path</param>
        /// <returns>0, GIT_ENOTFOUND if the path cannot exist or an error code</returns>
        /// <remarks>
        /// This function will retrieve the path of a specific repository
        /// item. It will thereby honor things like the repository's
        /// common directory, gitdir, etc. In case a file path cannot
        /// exist for a given item (e.g. the working directory of a bare
        /// repository), GIT_ENOTFOUND is returned.
        /// </remarks>
        public static git_result git_repository_item_path(out git_buf @out, git_repository repo, git_repository_item_t item)
        {
            var __result__ = git_repository_item_path__(out @out, repo, item).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_item_path", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_item_path__(out git_buf @out, git_repository repo, git_repository_item_t item);
        
        /// <summary>
        /// Get the path of this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>the path to the repository</returns>
        /// <remarks>
        /// This is the path of the `.git` folder for normal repositories,
        /// or of the repository itself for bare repositories.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static extern string git_repository_path(git_repository repo);
        
        /// <summary>
        /// Get the path of the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>the path to the working dir, if it exists</returns>
        /// <remarks>
        /// If the repository is bare, this function will always return
        /// NULL.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static extern string git_repository_workdir(git_repository repo);
        
        /// <summary>
        /// Get the path of the shared common directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>the path to the common dir</returns>
        /// <remarks>
        /// If the repository is bare is not a worktree, the git directory
        /// path is returned.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static extern string git_repository_commondir(git_repository repo);
        
        /// <summary>
        /// Set the path to the working directory for this repository
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="workdir">The path to a working directory</param>
        /// <param name="update_gitlink">Create/update gitlink in workdir and set config
        /// "core.worktree" (if workdir is not the parent of the .git directory)</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// The working directory doesn't need to be the same one
        /// that contains the `.git` folder for this repository.If this repository is bare, setting its working directory
        /// will turn it into a normal repository, capable of performing
        /// all the common workdir operations (checkout, status, index
        /// manipulation, etc).
        /// </remarks>
        public static git_result git_repository_set_workdir(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string workdir, [MarshalAs(UnmanagedType.Bool)] bool update_gitlink)
        {
            var __result__ = git_repository_set_workdir__(repo, workdir, update_gitlink).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_set_workdir", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_set_workdir__(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string workdir, [MarshalAs(UnmanagedType.Bool)] bool update_gitlink);
        
        /// <summary>
        /// Check if a repository is bare
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>1 if the repository is bare, 0 otherwise.</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.Bool)]
        public static extern bool git_repository_is_bare(git_repository repo);
        
        /// <summary>
        /// Check if a repository is a linked work tree
        /// </summary>
        /// <param name="repo">Repo to test</param>
        /// <returns>1 if the repository is a linked work tree, 0 otherwise.</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.Bool)]
        public static extern bool git_repository_is_worktree(git_repository repo);
        
        /// <summary>
        /// Get the configuration file for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded configuration</param>
        /// <param name="repo">A repository object</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// If a configuration file has not been set, the default
        /// config set for the repository will be returned, including
        /// global and system configurations (if they are available).The configuration file must be freed once it's no longer
        /// being used by the user.
        /// </remarks>
        public static git_result git_repository_config(out git_config @out, git_repository repo)
        {
            var __result__ = git_repository_config__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_config", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_config__(out git_config @out, git_repository repo);
        
        /// <summary>
        /// Get a snapshot of the repository's configuration
        /// </summary>
        /// <param name="out">Pointer to store the loaded configuration</param>
        /// <param name="repo">the repository</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// Convenience function to take a snapshot from the repository's
        /// configuration.  The contents of this snapshot will not change,
        /// even if the underlying config files are modified.The configuration file must be freed once it's no longer
        /// being used by the user.
        /// </remarks>
        public static git_result git_repository_config_snapshot(out git_config @out, git_repository repo)
        {
            var __result__ = git_repository_config_snapshot__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_config_snapshot", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_config_snapshot__(out git_config @out, git_repository repo);
        
        /// <summary>
        /// Get the Object Database for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded ODB</param>
        /// <param name="repo">A repository object</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// If a custom ODB has not been set, the default
        /// database for the repository will be returned (the one
        /// located in `.git/objects`).The ODB must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        public static git_result git_repository_odb(out git_odb @out, git_repository repo)
        {
            var __result__ = git_repository_odb__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_odb", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_odb__(out git_odb @out, git_repository repo);
        
        /// <summary>
        /// Get the Reference Database Backend for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded refdb</param>
        /// <param name="repo">A repository object</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// If a custom refsdb has not been set, the default database for
        /// the repository will be returned (the one that manipulates loose
        /// and packed references in the `.git` directory).The refdb must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        public static git_result git_repository_refdb(out git_refdb @out, git_repository repo)
        {
            var __result__ = git_repository_refdb__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_refdb", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_refdb__(out git_refdb @out, git_repository repo);
        
        /// <summary>
        /// Get the Index file for this repository.
        /// </summary>
        /// <param name="out">Pointer to store the loaded index</param>
        /// <param name="repo">A repository object</param>
        /// <returns>0, or an error code</returns>
        /// <remarks>
        /// If a custom index has not been set, the default
        /// index for the repository will be returned (the one
        /// located in `.git/index`).The index must be freed once it's no longer being used by
        /// the user.
        /// </remarks>
        public static git_result git_repository_index(out git_index @out, git_repository repo)
        {
            var __result__ = git_repository_index__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_index", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_index__(out git_index @out, git_repository repo);
        
        /// <summary>
        /// Retrieve git's prepared message
        /// </summary>
        /// <param name="out">git_buf to write data into</param>
        /// <param name="repo">Repository to read prepared message from</param>
        /// <returns>0, GIT_ENOTFOUND if no message exists or an error code</returns>
        /// <remarks>
        /// Operations such as git revert/cherry-pick/merge with the -n option
        /// stop just short of creating a commit with the changes and save
        /// their prepared message in .git/MERGE_MSG so the next git-commit
        /// execution can present it to the user for them to amend if they
        /// wish.Use this function to get the contents of this file. Don't forget to
        /// remove the file after you create the commit.
        /// </remarks>
        public static git_result git_repository_message(out git_buf @out, git_repository repo)
        {
            var __result__ = git_repository_message__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_message", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_message__(out git_buf @out, git_repository repo);
        
        /// <summary>
        /// Remove git's prepared message.
        /// </summary>
        /// <remarks>
        /// Remove the message that `git_repository_message` retrieves.
        /// </remarks>
        public static git_result git_repository_message_remove(git_repository repo)
        {
            var __result__ = git_repository_message_remove__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_message_remove", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_message_remove__(git_repository repo);
        
        /// <summary>
        /// Remove all the metadata associated with an ongoing command like merge,
        /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <returns>0 on success, or error</returns>
        public static git_result git_repository_state_cleanup(git_repository repo)
        {
            var __result__ = git_repository_state_cleanup__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_state_cleanup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_state_cleanup__(git_repository repo);
        
        /// <summary>
        /// Invoke 'callback' for each entry in the given FETCH_HEAD file.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="callback">Callback function</param>
        /// <param name="payload">Pointer to callback data (optional)</param>
        /// <returns>0 on success, non-zero callback return value, GIT_ENOTFOUND if
        /// there is no FETCH_HEAD file, or other error code.</returns>
        /// <remarks>
        /// Return a non-zero value from the callback to stop the loop.
        /// </remarks>
        public static git_result git_repository_fetchhead_foreach(git_repository repo, git_repository_fetchhead_foreach_cb callback, IntPtr payload)
        {
            var __result__ = git_repository_fetchhead_foreach__(repo, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_fetchhead_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_fetchhead_foreach__(git_repository repo, git_repository_fetchhead_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// If a merge is in progress, invoke 'callback' for each commit ID in the
        /// MERGE_HEAD file.
        /// </summary>
        /// <param name="repo">A repository object</param>
        /// <param name="callback">Callback function</param>
        /// <param name="payload">Pointer to callback data (optional)</param>
        /// <returns>0 on success, non-zero callback return value, GIT_ENOTFOUND if
        /// there is no MERGE_HEAD file, or other error code.</returns>
        /// <remarks>
        /// Return a non-zero value from the callback to stop the loop.
        /// </remarks>
        public static git_result git_repository_mergehead_foreach(git_repository repo, git_repository_mergehead_foreach_cb callback, IntPtr payload)
        {
            var __result__ = git_repository_mergehead_foreach__(repo, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_mergehead_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_mergehead_foreach__(git_repository repo, git_repository_mergehead_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Calculate hash of file using repository filtering rules.
        /// </summary>
        /// <param name="out">Output value of calculated SHA</param>
        /// <param name="repo">Repository pointer</param>
        /// <param name="path">Path to file on disk whose contents should be hashed. If the
        /// repository is not NULL, this can be a relative path.</param>
        /// <param name="type">The object type to hash as (e.g. GIT_OBJECT_BLOB)</param>
        /// <param name="as_path">The path to use to look up filtering rules. If this is
        /// NULL, then the `path` parameter will be used instead. If
        /// this is passed as the empty string, then no filters will be
        /// applied when calculating the hash.</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// If you simply want to calculate the hash of a file on disk with no filters,
        /// you can just use the `git_odb_hashfile()` API.  However, if you want to
        /// hash a file in the repository and you want to apply filtering rules (e.g.
        /// crlf filters) before generating the SHA, then use this function.Note: if the repository has `core.safecrlf` set to fail and the
        /// filtering triggers that failure, then this function will return an
        /// error and not calculate the hash of the file.
        /// </remarks>
        public static git_result git_repository_hashfile(out git_oid @out, git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_object_t type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string as_path)
        {
            var __result__ = git_repository_hashfile__(out @out, repo, path, type, as_path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_hashfile", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_hashfile__(out git_oid @out, git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_object_t type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string as_path);
        
        /// <summary>
        /// Make the repository HEAD point to the specified reference.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <param name="refname">Canonical name of the reference the HEAD should point at</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// If the provided reference points to a Tree or a Blob, the HEAD is
        /// unaltered and -1 is returned.If the provided reference points to a branch, the HEAD will point
        /// to that branch, staying attached, or become attached if it isn't yet.
        /// If the branch doesn't exist yet, no error will be return. The HEAD
        /// will then be attached to an unborn branch.Otherwise, the HEAD will be detached and will directly point to
        /// the Commit.
        /// </remarks>
        public static git_result git_repository_set_head(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string refname)
        {
            var __result__ = git_repository_set_head__(repo, refname).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_set_head", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_set_head__(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string refname);
        
        /// <summary>
        /// Make the repository HEAD directly point to the Commit.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <param name="commitish">Object id of the Commit the HEAD should point to</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// If the provided committish cannot be found in the repository, the HEAD
        /// is unaltered and GIT_ENOTFOUND is returned.If the provided commitish cannot be peeled into a commit, the HEAD
        /// is unaltered and -1 is returned.Otherwise, the HEAD will eventually be detached and will directly point to
        /// the peeled Commit.
        /// </remarks>
        public static git_result git_repository_set_head_detached(git_repository repo, in git_oid commitish)
        {
            var __result__ = git_repository_set_head_detached__(repo, commitish).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_set_head_detached", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_set_head_detached__(git_repository repo, in git_oid commitish);
        
        /// <summary>
        /// Make the repository HEAD directly point to the Commit.
        /// </summary>
        /// <seealso cref="git_repository_set_head_detached"/>
        /// 
        /// <remarks>
        /// This behaves like `git_repository_set_head_detached()` but takes an
        /// annotated commit, which lets you specify which extended sha syntax
        /// string was specified by a user, allowing for more exact reflog
        /// messages.See the documentation for `git_repository_set_head_detached()`.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_repository_set_head_detached_from_annotated(git_repository repo, git_annotated_commit commitish);
        
        /// <summary>
        /// Detach the HEAD.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <returns>0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
        /// branch or an error code</returns>
        /// <remarks>
        /// If the HEAD is already detached and points to a Commit, 0 is returned.If the HEAD is already detached and points to a Tag, the HEAD is
        /// updated into making it point to the peeled Commit, and 0 is returned.If the HEAD is already detached and points to a non commitish, the HEAD is
        /// unaltered, and -1 is returned.Otherwise, the HEAD will be detached and point to the peeled Commit.
        /// </remarks>
        public static git_result git_repository_detach_head(git_repository repo)
        {
            var __result__ = git_repository_detach_head__(repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_detach_head", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_detach_head__(git_repository repo);
        
        /// <summary>
        /// Determines the status of a git repository - ie, whether an operation
        /// (merge, cherry-pick, etc) is in progress.
        /// </summary>
        /// <param name="repo">Repository pointer</param>
        /// <returns>The state of the repository</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository_state_t git_repository_state(git_repository repo);
        
        /// <summary>
        /// Sets the active namespace for this Git Repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <param name="nmspace">The namespace. This should not include the refs
        /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
        /// use `foo` as the namespace.</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>
        /// This namespace affects all reference operations for the repo.
        /// See `man gitnamespaces`
        /// </remarks>
        public static git_result git_repository_set_namespace(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string nmspace)
        {
            var __result__ = git_repository_set_namespace__(repo, nmspace).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_set_namespace", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_set_namespace__(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string nmspace);
        
        /// <summary>
        /// Get the currently active namespace for this repository
        /// </summary>
        /// <param name="repo">The repo</param>
        /// <returns>the active namespace, or NULL if there isn't one</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
        public static extern string git_repository_get_namespace(git_repository repo);
        
        /// <summary>
        /// Determine if the repository was a shallow clone
        /// </summary>
        /// <param name="repo">The repository</param>
        /// <returns>1 if shallow, zero if not</returns>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.Bool)]
        public static extern bool git_repository_is_shallow(git_repository repo);
        
        /// <summary>
        /// Retrieve the configured identity to use for reflogs
        /// </summary>
        /// <param name="name">where to store the pointer to the name</param>
        /// <param name="email">where to store the pointer to the email</param>
        /// <param name="repo">the repository</param>
        /// <remarks>
        /// The memory is owned by the repository and must not be freed by the
        /// user.
        /// </remarks>
        public static git_result git_repository_ident(out string name, out string email, git_repository repo)
        {
            var __result__ = git_repository_ident__(out name, out email, repo).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_ident", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_ident__(out string name, out string email, git_repository repo);
        
        /// <summary>
        /// Set the identity to be used for writing reflogs
        /// </summary>
        /// <param name="repo">the repository to configure</param>
        /// <param name="name">the name to use for the reflog entries</param>
        /// <param name="email">the email to use for the reflog entries</param>
        /// <remarks>
        /// If both are set, this name and email will be used to write to the
        /// reflog. Pass NULL to unset. When unset, the identity will be taken
        /// from the repository's configuration.
        /// </remarks>
        public static git_result git_repository_set_ident(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string email)
        {
            var __result__ = git_repository_set_ident__(repo, name, email).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_repository_set_ident", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_repository_set_ident__(git_repository repo, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string email);
    }
}
