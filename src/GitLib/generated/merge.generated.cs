//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Flags for `git_merge` options.  A combination of these flags can be
        /// passed in via the `flags` value in the `git_merge_options`.
        /// </summary>
        [Flags]
        public enum git_merge_flag_t : int
        {
            /// <summary>
            /// Detect renames that occur between the common ancestor and the "ours"
            /// side or the common ancestor and the "theirs" side.  This will enable
            /// the ability to merge between a modified and renamed file.
            /// </summary>
            GIT_MERGE_FIND_RENAMES = (int)(1 << 0),
            
            /// <summary>
            /// If a conflict occurs, exit immediately instead of attempting to
            /// continue resolving conflicts.  The merge operation will fail with
            /// GIT_EMERGECONFLICT and no index will be returned.
            /// </summary>
            GIT_MERGE_FAIL_ON_CONFLICT = (int)(1 << 1),
            
            /// <summary>
            /// Do not write the REUC extension on the generated index
            /// </summary>
            GIT_MERGE_SKIP_REUC = (int)(1 << 2),
            
            /// <summary>
            /// If the commits being merged have multiple merge bases, do not build
            /// a recursive merge base (by merging the multiple merge bases),
            /// instead simply use the first base.  This flag provides a similar
            /// merge base to `git-merge-resolve`.
            /// </summary>
            GIT_MERGE_NO_RECURSIVE = (int)(1 << 3),
        }
        
        /// <summary>
        /// Detect renames that occur between the common ancestor and the "ours"
        /// side or the common ancestor and the "theirs" side.  This will enable
        /// the ability to merge between a modified and renamed file.
        /// </summary>
        public const git_merge_flag_t GIT_MERGE_FIND_RENAMES = git_merge_flag_t.GIT_MERGE_FIND_RENAMES;
        
        /// <summary>
        /// If a conflict occurs, exit immediately instead of attempting to
        /// continue resolving conflicts.  The merge operation will fail with
        /// GIT_EMERGECONFLICT and no index will be returned.
        /// </summary>
        public const git_merge_flag_t GIT_MERGE_FAIL_ON_CONFLICT = git_merge_flag_t.GIT_MERGE_FAIL_ON_CONFLICT;
        
        /// <summary>
        /// Do not write the REUC extension on the generated index
        /// </summary>
        public const git_merge_flag_t GIT_MERGE_SKIP_REUC = git_merge_flag_t.GIT_MERGE_SKIP_REUC;
        
        /// <summary>
        /// If the commits being merged have multiple merge bases, do not build
        /// a recursive merge base (by merging the multiple merge bases),
        /// instead simply use the first base.  This flag provides a similar
        /// merge base to `git-merge-resolve`.
        /// </summary>
        public const git_merge_flag_t GIT_MERGE_NO_RECURSIVE = git_merge_flag_t.GIT_MERGE_NO_RECURSIVE;
        
        /// <summary>
        /// Merge file favor options for `git_merge_options` instruct the file-level
        /// merging functionality how to deal with conflicting regions of the files.
        /// </summary>
        public enum git_merge_file_favor_t : int
        {
            /// <summary>
            /// When a region of a file is changed in both branches, a conflict
            /// will be recorded in the index so that `git_checkout` can produce
            /// a merge file with conflict markers in the working directory.
            /// This is the default.
            /// </summary>
            GIT_MERGE_FILE_FAVOR_NORMAL = (int)0,
            
            /// <summary>
            /// When a region of a file is changed in both branches, the file
            /// created in the index will contain the "ours" side of any conflicting
            /// region.  The index will not record a conflict.
            /// </summary>
            GIT_MERGE_FILE_FAVOR_OURS = (int)1,
            
            /// <summary>
            /// When a region of a file is changed in both branches, the file
            /// created in the index will contain the "theirs" side of any conflicting
            /// region.  The index will not record a conflict.
            /// </summary>
            GIT_MERGE_FILE_FAVOR_THEIRS = (int)2,
            
            /// <summary>
            /// When a region of a file is changed in both branches, the file
            /// created in the index will contain each unique line from each side,
            /// which has the result of combining both files.  The index will not
            /// record a conflict.
            /// </summary>
            GIT_MERGE_FILE_FAVOR_UNION = (int)3,
        }
        
        /// <summary>
        /// When a region of a file is changed in both branches, a conflict
        /// will be recorded in the index so that `git_checkout` can produce
        /// a merge file with conflict markers in the working directory.
        /// This is the default.
        /// </summary>
        public const git_merge_file_favor_t GIT_MERGE_FILE_FAVOR_NORMAL = git_merge_file_favor_t.GIT_MERGE_FILE_FAVOR_NORMAL;
        
        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain the "ours" side of any conflicting
        /// region.  The index will not record a conflict.
        /// </summary>
        public const git_merge_file_favor_t GIT_MERGE_FILE_FAVOR_OURS = git_merge_file_favor_t.GIT_MERGE_FILE_FAVOR_OURS;
        
        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain the "theirs" side of any conflicting
        /// region.  The index will not record a conflict.
        /// </summary>
        public const git_merge_file_favor_t GIT_MERGE_FILE_FAVOR_THEIRS = git_merge_file_favor_t.GIT_MERGE_FILE_FAVOR_THEIRS;
        
        /// <summary>
        /// When a region of a file is changed in both branches, the file
        /// created in the index will contain each unique line from each side,
        /// which has the result of combining both files.  The index will not
        /// record a conflict.
        /// </summary>
        public const git_merge_file_favor_t GIT_MERGE_FILE_FAVOR_UNION = git_merge_file_favor_t.GIT_MERGE_FILE_FAVOR_UNION;
        
        /// <summary>
        /// File merging flags
        /// </summary>
        [Flags]
        public enum git_merge_file_flag_t : int
        {
            /// <summary>
            /// Defaults
            /// </summary>
            GIT_MERGE_FILE_DEFAULT = (int)0,
            
            /// <summary>
            /// Create standard conflicted merge files
            /// </summary>
            GIT_MERGE_FILE_STYLE_MERGE = (int)(1 << 0),
            
            /// <summary>
            /// Create diff3-style files
            /// </summary>
            GIT_MERGE_FILE_STYLE_DIFF3 = (int)(1 << 1),
            
            /// <summary>
            /// Condense non-alphanumeric regions for simplified diff file
            /// </summary>
            GIT_MERGE_FILE_SIMPLIFY_ALNUM = (int)(1 << 2),
            
            /// <summary>
            /// Ignore all whitespace
            /// </summary>
            GIT_MERGE_FILE_IGNORE_WHITESPACE = (int)(1 << 3),
            
            /// <summary>
            /// Ignore changes in amount of whitespace
            /// </summary>
            GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = (int)(1 << 4),
            
            /// <summary>
            /// Ignore whitespace at end of line
            /// </summary>
            GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = (int)(1 << 5),
            
            /// <summary>
            /// Use the "patience diff" algorithm
            /// </summary>
            GIT_MERGE_FILE_DIFF_PATIENCE = (int)(1 << 6),
            
            /// <summary>
            /// Take extra time to find minimal diff
            /// </summary>
            GIT_MERGE_FILE_DIFF_MINIMAL = (int)(1 << 7),
        }
        
        /// <summary>
        /// Defaults
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_DEFAULT = git_merge_file_flag_t.GIT_MERGE_FILE_DEFAULT;
        
        /// <summary>
        /// Create standard conflicted merge files
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_STYLE_MERGE = git_merge_file_flag_t.GIT_MERGE_FILE_STYLE_MERGE;
        
        /// <summary>
        /// Create diff3-style files
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_STYLE_DIFF3 = git_merge_file_flag_t.GIT_MERGE_FILE_STYLE_DIFF3;
        
        /// <summary>
        /// Condense non-alphanumeric regions for simplified diff file
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_SIMPLIFY_ALNUM = git_merge_file_flag_t.GIT_MERGE_FILE_SIMPLIFY_ALNUM;
        
        /// <summary>
        /// Ignore all whitespace
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_IGNORE_WHITESPACE = git_merge_file_flag_t.GIT_MERGE_FILE_IGNORE_WHITESPACE;
        
        /// <summary>
        /// Ignore changes in amount of whitespace
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = git_merge_file_flag_t.GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE;
        
        /// <summary>
        /// Ignore whitespace at end of line
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = git_merge_file_flag_t.GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL;
        
        /// <summary>
        /// Use the "patience diff" algorithm
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_DIFF_PATIENCE = git_merge_file_flag_t.GIT_MERGE_FILE_DIFF_PATIENCE;
        
        /// <summary>
        /// Take extra time to find minimal diff
        /// </summary>
        public const git_merge_file_flag_t GIT_MERGE_FILE_DIFF_MINIMAL = git_merge_file_flag_t.GIT_MERGE_FILE_DIFF_MINIMAL;
        
        /// <summary>
        /// The results of `git_merge_analysis` indicate the merge opportunities.
        /// </summary>
        [Flags]
        public enum git_merge_analysis_t : int
        {
            /// <summary>
            /// No merge is possible.  (Unused.)
            /// </summary>
            GIT_MERGE_ANALYSIS_NONE = (int)0,
            
            /// <summary>
            /// A "normal" merge; both HEAD and the given merge input have diverged
            /// from their common ancestor.  The divergent commits must be merged.
            /// </summary>
            GIT_MERGE_ANALYSIS_NORMAL = (int)(1 << 0),
            
            /// <summary>
            /// All given merge inputs are reachable from HEAD, meaning the
            /// repository is up-to-date and no merge needs to be performed.
            /// </summary>
            GIT_MERGE_ANALYSIS_UP_TO_DATE = (int)(1 << 1),
            
            /// <summary>
            /// The given merge input is a fast-forward from HEAD and no merge
            /// needs to be performed.  Instead, the client can check out the
            /// given merge input.
            /// </summary>
            GIT_MERGE_ANALYSIS_FASTFORWARD = (int)(1 << 2),
            
            /// <summary>
            /// The HEAD of the current repository is "unborn" and does not point to
            /// a valid commit.  No merge can be performed, but the caller may wish
            /// to simply set HEAD to the target commit(s).
            /// </summary>
            GIT_MERGE_ANALYSIS_UNBORN = (int)(1 << 3),
        }
        
        /// <summary>
        /// No merge is possible.  (Unused.)
        /// </summary>
        public const git_merge_analysis_t GIT_MERGE_ANALYSIS_NONE = git_merge_analysis_t.GIT_MERGE_ANALYSIS_NONE;
        
        /// <summary>
        /// A "normal" merge; both HEAD and the given merge input have diverged
        /// from their common ancestor.  The divergent commits must be merged.
        /// </summary>
        public const git_merge_analysis_t GIT_MERGE_ANALYSIS_NORMAL = git_merge_analysis_t.GIT_MERGE_ANALYSIS_NORMAL;
        
        /// <summary>
        /// All given merge inputs are reachable from HEAD, meaning the
        /// repository is up-to-date and no merge needs to be performed.
        /// </summary>
        public const git_merge_analysis_t GIT_MERGE_ANALYSIS_UP_TO_DATE = git_merge_analysis_t.GIT_MERGE_ANALYSIS_UP_TO_DATE;
        
        /// <summary>
        /// The given merge input is a fast-forward from HEAD and no merge
        /// needs to be performed.  Instead, the client can check out the
        /// given merge input.
        /// </summary>
        public const git_merge_analysis_t GIT_MERGE_ANALYSIS_FASTFORWARD = git_merge_analysis_t.GIT_MERGE_ANALYSIS_FASTFORWARD;
        
        /// <summary>
        /// The HEAD of the current repository is "unborn" and does not point to
        /// a valid commit.  No merge can be performed, but the caller may wish
        /// to simply set HEAD to the target commit(s).
        /// </summary>
        public const git_merge_analysis_t GIT_MERGE_ANALYSIS_UNBORN = git_merge_analysis_t.GIT_MERGE_ANALYSIS_UNBORN;
        
        /// <summary>
        /// The user's stated preference for merges.
        /// </summary>
        [Flags]
        public enum git_merge_preference_t : int
        {
            /// <summary>
            /// No configuration was found that suggests a preferred behavior for
            /// merge.
            /// </summary>
            GIT_MERGE_PREFERENCE_NONE = (int)0,
            
            /// <summary>
            /// There is a `merge.ff=false` configuration setting, suggesting that
            /// the user does not want to allow a fast-forward merge.
            /// </summary>
            GIT_MERGE_PREFERENCE_NO_FASTFORWARD = (int)(1 << 0),
            
            /// <summary>
            /// There is a `merge.ff=only` configuration setting, suggesting that
            /// the user only wants fast-forward merges.
            /// </summary>
            GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = (int)(1 << 1),
        }
        
        /// <summary>
        /// No configuration was found that suggests a preferred behavior for
        /// merge.
        /// </summary>
        public const git_merge_preference_t GIT_MERGE_PREFERENCE_NONE = git_merge_preference_t.GIT_MERGE_PREFERENCE_NONE;
        
        /// <summary>
        /// There is a `merge.ff=false` configuration setting, suggesting that
        /// the user does not want to allow a fast-forward merge.
        /// </summary>
        public const git_merge_preference_t GIT_MERGE_PREFERENCE_NO_FASTFORWARD = git_merge_preference_t.GIT_MERGE_PREFERENCE_NO_FASTFORWARD;
        
        /// <summary>
        /// There is a `merge.ff=only` configuration setting, suggesting that
        /// the user only wants fast-forward merges.
        /// </summary>
        public const git_merge_preference_t GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = git_merge_preference_t.GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;
        
        /// <summary>
        /// The file inputs to `git_merge_file`.  Callers should populate the
        /// `git_merge_file_input` structure with descriptions of the files in
        /// each side of the conflict for use in producing the merge file.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_merge_file_input
        {
            public uint version;
            
            /// <summary>
            /// Pointer to the contents of the file.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string ptr;
            
            /// <summary>
            /// Size of the contents pointed to in `ptr`.
            /// </summary>
            public size_t size;
            
            /// <summary>
            /// File name of the conflicted file, or `NULL` to not merge the path.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string path;
            
            /// <summary>
            /// File mode of the conflicted file, or `0` to not merge the mode.
            /// </summary>
            public uint mode;
        }
        
        /// <summary>
        /// Options for merging a file
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_merge_file_options
        {
            public uint version;
            
            /// <summary>
            /// Label for the ancestor file side of the conflict which will be prepended
            /// to labels in diff3-format merge files.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string ancestor_label;
            
            /// <summary>
            /// Label for our file side of the conflict which will be prepended
            /// to labels in merge files.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string our_label;
            
            /// <summary>
            /// Label for their file side of the conflict which will be prepended
            /// to labels in merge files.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string their_label;
            
            /// <summary>
            /// The file to favor in region conflicts.
            /// </summary>
            public git_merge_file_favor_t favor;
            
            /// <summary>
            /// see `git_merge_file_flag_t` above
            /// </summary>
            public git_merge_file_flag_t flags;
            
            /// <summary>
            /// The size of conflict markers (eg, "
            /// &lt;
            /// &lt;
            /// &lt;
            /// &lt;
            /// &lt;
            /// &lt;
            /// &lt;
            /// ").  Default is
            /// GIT_MERGE_CONFLICT_MARKER_SIZE.
            /// </summary>
            public ushort marker_size;
        }
        
        /// <summary>
        /// Information about file-level merging
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_merge_file_result
        {
            /// <summary>
            /// True if the output was automerged, false if the output contains
            /// conflict markers.
            /// </summary>
            public uint automergeable;
            
            /// <summary>
            /// The path that the resultant merge file should use, or NULL if a
            /// filename conflict would occur.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string path;
            
            /// <summary>
            /// The mode that the resultant merge file should use.
            /// </summary>
            public uint mode;
            
            /// <summary>
            /// The contents of the merge.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string ptr;
            
            /// <summary>
            /// The length of the merge contents.
            /// </summary>
            public size_t len;
        }
        
        /// <summary>
        /// Merging options
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_merge_options
        {
            public uint version;
            
            /// <summary>
            /// See `git_merge_flag_t` above
            /// </summary>
            public git_merge_flag_t flags;
            
            /// <summary>
            /// Similarity to consider a file renamed (default 50).  If
            /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
            /// with deleted files to determine their similarity.  Files that are
            /// more similar than the rename threshold (percentage-wise) will be
            /// treated as a rename.
            /// </summary>
            public uint rename_threshold;
            
            /// <summary>
            /// Maximum similarity sources to examine for renames (default 200).
            /// If the number of rename candidates (add / delete pairs) is greater
            /// than this value, inexact rename detection is aborted.
            /// </summary>
            /// <remarks>
            /// This setting overrides the `merge.renameLimit` configuration value.
            /// </remarks>
            public uint target_limit;
            
            /// <summary>
            /// Pluggable similarity metric; pass NULL to use internal metric
            /// </summary>
            public IntPtr metric;
            
            /// <summary>
            /// Maximum number of times to merge common ancestors to build a
            /// virtual merge base when faced with criss-cross merges.  When this
            /// limit is reached, the next ancestor will simply be used instead of
            /// attempting to merge it.  The default is unlimited.
            /// </summary>
            public uint recursion_limit;
            
            /// <summary>
            /// Default merge driver to be used when both sides of a merge have
            /// changed.  The default is the `text` driver.
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string default_driver;
            
            /// <summary>
            /// Flags for handling conflicting content, to be used with the standard
            /// (`text`) merge driver.
            /// </summary>
            public git_merge_file_favor_t file_favor;
            
            /// <summary>
            /// see `git_merge_file_flag_t` above
            /// </summary>
            public git_merge_file_flag_t file_flags;
        }
        
        /// <summary>
        /// Initializes a `git_merge_file_input` with default values. Equivalent to
        /// creating an instance with GIT_MERGE_FILE_INPUT_INIT.
        /// </summary>
        /// <param name="opts">the `git_merge_file_input` instance to initialize.</param>
        /// <param name="version">the version of the struct; you should pass
        /// `GIT_MERGE_FILE_INPUT_VERSION` here.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        public static git_result git_merge_file_init_input(ref git_merge_file_input opts, uint version)
        {
            var __result__ = git_merge_file_init_input__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_file_init_input", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_file_init_input__(ref git_merge_file_input opts, uint version);
        
        /// <summary>
        /// Initialize git_merge_file_options structure
        /// </summary>
        /// <param name="opts">The `git_merge_file_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_MERGE_FILE_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_merge_file_options` with default values. Equivalent to
        /// creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_merge_file_init_options(ref git_merge_file_options opts, uint version)
        {
            var __result__ = git_merge_file_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_file_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_file_init_options__(ref git_merge_file_options opts, uint version);
        
        /// <summary>
        /// Initialize git_merge_options structure
        /// </summary>
        /// <param name="opts">The `git_merge_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_merge_options` with default values. Equivalent to
        /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_merge_init_options(ref git_merge_options opts, uint version)
        {
            var __result__ = git_merge_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_init_options__(ref git_merge_options opts, uint version);
        
        /// <summary>
        /// Analyzes the given branch(es) and determines the opportunities for
        /// merging them into the HEAD of the repository.
        /// </summary>
        /// <param name="analysis_out">analysis enumeration that the result is written into</param>
        /// <param name="repo">the repository to merge</param>
        /// <param name="their_heads">the heads to merge into</param>
        /// <param name="their_heads_len">the number of heads to merge</param>
        /// <returns>0 on success or error code</returns>
        public static git_result git_merge_analysis(ref git_merge_analysis_t analysis_out, ref git_merge_preference_t preference_out, git_repository repo, out git_annotated_commit their_heads, size_t their_heads_len)
        {
            var __result__ = git_merge_analysis__(ref analysis_out, ref preference_out, repo, out their_heads, their_heads_len).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_analysis", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_analysis__(ref git_merge_analysis_t analysis_out, ref git_merge_preference_t preference_out, git_repository repo, out git_annotated_commit their_heads, size_t their_heads_len);
        
        /// <summary>
        /// Analyzes the given branch(es) and determines the opportunities for
        /// merging them into a reference.
        /// </summary>
        /// <param name="analysis_out">analysis enumeration that the result is written into</param>
        /// <param name="repo">the repository to merge</param>
        /// <param name="our_ref">the reference to perform the analysis from</param>
        /// <param name="their_heads">the heads to merge into</param>
        /// <param name="their_heads_len">the number of heads to merge</param>
        /// <returns>0 on success or error code</returns>
        public static git_result git_merge_analysis_for_ref(ref git_merge_analysis_t analysis_out, ref git_merge_preference_t preference_out, git_repository repo, git_reference our_ref, out git_annotated_commit their_heads, size_t their_heads_len)
        {
            var __result__ = git_merge_analysis_for_ref__(ref analysis_out, ref preference_out, repo, our_ref, out their_heads, their_heads_len).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_analysis_for_ref", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_analysis_for_ref__(ref git_merge_analysis_t analysis_out, ref git_merge_preference_t preference_out, git_repository repo, git_reference our_ref, out git_annotated_commit their_heads, size_t their_heads_len);
        
        /// <summary>
        /// Find a merge base between two commits
        /// </summary>
        /// <param name="out">the OID of a merge base between 'one' and 'two'</param>
        /// <param name="repo">the repository where the commits exist</param>
        /// <param name="one">one of the commits</param>
        /// <param name="two">the other commit</param>
        /// <returns>0 on success, GIT_ENOTFOUND if not found or error code</returns>
        public static git_result git_merge_base(out git_oid @out, git_repository repo, in git_oid one, in git_oid two)
        {
            var __result__ = git_merge_base__(out @out, repo, one, two).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_base", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_base__(out git_oid @out, git_repository repo, in git_oid one, in git_oid two);
        
        /// <summary>
        /// Find merge bases between two commits
        /// </summary>
        /// <param name="out">array in which to store the resulting ids</param>
        /// <param name="repo">the repository where the commits exist</param>
        /// <param name="one">one of the commits</param>
        /// <param name="two">the other commit</param>
        /// <returns>0 on success, GIT_ENOTFOUND if not found or error code</returns>
        public static git_result git_merge_bases(out git_oidarray @out, git_repository repo, in git_oid one, in git_oid two)
        {
            var __result__ = git_merge_bases__(out @out, repo, one, two).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_bases", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_bases__(out git_oidarray @out, git_repository repo, in git_oid one, in git_oid two);
        
        /// <summary>
        /// Find a merge base given a list of commits
        /// </summary>
        /// <param name="out">the OID of a merge base considering all the commits</param>
        /// <param name="repo">the repository where the commits exist</param>
        /// <param name="length">The number of commits in the provided `input_array`</param>
        /// <param name="input_array">oids of the commits</param>
        /// <returns>Zero on success; GIT_ENOTFOUND or -1 on failure.</returns>
        public static git_result git_merge_base_many(out git_oid @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array)
        {
            var __result__ = git_merge_base_many__(out @out, repo, length, input_array).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_base_many", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_base_many__(out git_oid @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array);
        
        /// <summary>
        /// Find all merge bases given a list of commits
        /// </summary>
        /// <param name="out">array in which to store the resulting ids</param>
        /// <param name="repo">the repository where the commits exist</param>
        /// <param name="length">The number of commits in the provided `input_array`</param>
        /// <param name="input_array">oids of the commits</param>
        /// <returns>Zero on success; GIT_ENOTFOUND or -1 on failure.</returns>
        public static git_result git_merge_bases_many(out git_oidarray @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array)
        {
            var __result__ = git_merge_bases_many__(out @out, repo, length, input_array).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_bases_many", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_bases_many__(out git_oidarray @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array);
        
        /// <summary>
        /// Find a merge base in preparation for an octopus merge
        /// </summary>
        /// <param name="out">the OID of a merge base considering all the commits</param>
        /// <param name="repo">the repository where the commits exist</param>
        /// <param name="length">The number of commits in the provided `input_array`</param>
        /// <param name="input_array">oids of the commits</param>
        /// <returns>Zero on success; GIT_ENOTFOUND or -1 on failure.</returns>
        public static git_result git_merge_base_octopus(out git_oid @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array)
        {
            var __result__ = git_merge_base_octopus__(out @out, repo, length, input_array).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_base_octopus", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_base_octopus__(out git_oid @out, git_repository repo, size_t length, [MarshalAs(UnmanagedType.LPArray)] git_oid[] input_array);
        
        /// <summary>
        /// Merge two files as they exist in the in-memory data structures, using
        /// the given common ancestor as the baseline, producing a
        /// `git_merge_file_result` that reflects the merge result.  The
        /// `git_merge_file_result` must be freed with `git_merge_file_result_free`.
        /// </summary>
        /// <param name="out">The git_merge_file_result to be filled in</param>
        /// <param name="ancestor">The contents of the ancestor file</param>
        /// <param name="ours">The contents of the file in "our" side</param>
        /// <param name="theirs">The contents of the file in "their" side</param>
        /// <param name="opts">The merge file options or `NULL` for defaults</param>
        /// <returns>0 on success or error code</returns>
        /// <remarks>
        /// Note that this function does not reference a repository and any
        /// configuration must be passed as `git_merge_file_options`.
        /// </remarks>
        public static git_result git_merge_file(out git_merge_file_result @out, in git_merge_file_input ancestor, in git_merge_file_input ours, in git_merge_file_input theirs, in git_merge_file_options opts)
        {
            var __result__ = git_merge_file__(out @out, ancestor, ours, theirs, opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_file", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_file__(out git_merge_file_result @out, in git_merge_file_input ancestor, in git_merge_file_input ours, in git_merge_file_input theirs, in git_merge_file_options opts);
        
        /// <summary>
        /// Merge two files as they exist in the index, using the given common
        /// ancestor as the baseline, producing a `git_merge_file_result` that
        /// reflects the merge result.  The `git_merge_file_result` must be freed with
        /// `git_merge_file_result_free`.
        /// </summary>
        /// <param name="out">The git_merge_file_result to be filled in</param>
        /// <param name="repo">The repository</param>
        /// <param name="ancestor">The index entry for the ancestor file (stage level 1)</param>
        /// <param name="ours">The index entry for our file (stage level 2)</param>
        /// <param name="theirs">The index entry for their file (stage level 3)</param>
        /// <param name="opts">The merge file options or NULL</param>
        /// <returns>0 on success or error code</returns>
        public static git_result git_merge_file_from_index(out git_merge_file_result @out, git_repository repo, in git_index_entry ancestor, in git_index_entry ours, in git_index_entry theirs, in git_merge_file_options opts)
        {
            var __result__ = git_merge_file_from_index__(out @out, repo, ancestor, ours, theirs, opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_file_from_index", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_file_from_index__(out git_merge_file_result @out, git_repository repo, in git_index_entry ancestor, in git_index_entry ours, in git_index_entry theirs, in git_merge_file_options opts);
        
        /// <summary>
        /// Frees a `git_merge_file_result`.
        /// </summary>
        /// <param name="result">The result to free or `NULL`</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_merge_file_result_free(ref git_merge_file_result result);
        
        /// <summary>
        /// Merge two trees, producing a `git_index` that reflects the result of
        /// the merge.  The index may be written as-is to the working directory
        /// or checked out.  If the index is to be converted to a tree, the caller
        /// should resolve any conflicts that arose as part of the merge.
        /// </summary>
        /// <param name="out">pointer to store the index result in</param>
        /// <param name="repo">repository that contains the given trees</param>
        /// <param name="ancestor_tree">the common ancestor between the trees (or null if none)</param>
        /// <param name="our_tree">the tree that reflects the destination tree</param>
        /// <param name="their_tree">the tree to merge in to `our_tree`</param>
        /// <param name="opts">the merge tree options (or null for defaults)</param>
        /// <returns>0 on success or error code</returns>
        /// <remarks>
        /// The returned index must be freed explicitly with `git_index_free`.
        /// </remarks>
        public static git_result git_merge_trees(out git_index @out, git_repository repo, git_tree ancestor_tree, git_tree our_tree, git_tree their_tree, in git_merge_options opts)
        {
            var __result__ = git_merge_trees__(out @out, repo, ancestor_tree, our_tree, their_tree, opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_trees", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_trees__(out git_index @out, git_repository repo, git_tree ancestor_tree, git_tree our_tree, git_tree their_tree, in git_merge_options opts);
        
        /// <summary>
        /// Merge two commits, producing a `git_index` that reflects the result of
        /// the merge.  The index may be written as-is to the working directory
        /// or checked out.  If the index is to be converted to a tree, the caller
        /// should resolve any conflicts that arose as part of the merge.
        /// </summary>
        /// <param name="out">pointer to store the index result in</param>
        /// <param name="repo">repository that contains the given trees</param>
        /// <param name="our_commit">the commit that reflects the destination tree</param>
        /// <param name="their_commit">the commit to merge in to `our_commit`</param>
        /// <param name="opts">the merge tree options (or null for defaults)</param>
        /// <returns>0 on success or error code</returns>
        /// <remarks>
        /// The returned index must be freed explicitly with `git_index_free`.
        /// </remarks>
        public static git_result git_merge_commits(out git_index @out, git_repository repo, git_commit our_commit, git_commit their_commit, in git_merge_options opts)
        {
            var __result__ = git_merge_commits__(out @out, repo, our_commit, their_commit, opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge_commits", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge_commits__(out git_index @out, git_repository repo, git_commit our_commit, git_commit their_commit, in git_merge_options opts);
        
        /// <summary>
        /// Merges the given commit(s) into HEAD, writing the results into the working
        /// directory.  Any changes are staged for commit and any conflicts are written
        /// to the index.  Callers should inspect the repository's index after this
        /// completes, resolve any conflicts and prepare a commit.
        /// </summary>
        /// <param name="repo">the repository to merge</param>
        /// <param name="their_heads">the heads to merge into</param>
        /// <param name="their_heads_len">the number of heads to merge</param>
        /// <param name="merge_opts">merge options</param>
        /// <param name="checkout_opts">checkout options</param>
        /// <returns>0 on success or error code</returns>
        /// <remarks>
        /// For compatibility with git, the repository is put into a merging
        /// state. Once the commit is done (or if the uses wishes to abort),
        /// you should clear this state by calling
        /// `git_repository_state_cleanup()`.
        /// </remarks>
        public static git_result git_merge(git_repository repo, out git_annotated_commit their_heads, size_t their_heads_len, in git_merge_options merge_opts, in git_checkout_options checkout_opts)
        {
            var __result__ = git_merge__(repo, out their_heads, their_heads_len, merge_opts, checkout_opts).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_merge", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_merge__(git_repository repo, out git_annotated_commit their_heads, size_t their_heads_len, in git_merge_options merge_opts, in git_checkout_options checkout_opts);
    }
}
