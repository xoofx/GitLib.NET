//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace GitLib
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Priority level of a config file.
        /// These priority levels correspond to the natural escalation logic
        /// (from higher to lower) when searching for config entries in git.git.
        /// </summary>
        /// <remarks>
        /// git_config_open_default() and git_repository_config() honor those
        /// priority levels as well.
        /// </remarks>
        public enum git_config_level_t : int
        {
            /// <summary>
            /// System-wide on Windows, for compatibility with portable git
            /// </summary>
            GIT_CONFIG_LEVEL_PROGRAMDATA = (int)1,
            
            /// <summary>
            /// System-wide configuration file; /etc/gitconfig on Linux systems
            /// </summary>
            GIT_CONFIG_LEVEL_SYSTEM = (int)2,
            
            /// <summary>
            /// XDG compatible configuration file; typically ~/.config/git/config
            /// </summary>
            GIT_CONFIG_LEVEL_XDG = (int)3,
            
            /// <summary>
            /// User-specific configuration file (also called Global configuration
            /// file); typically ~/.gitconfig
            /// </summary>
            GIT_CONFIG_LEVEL_GLOBAL = (int)4,
            
            /// <summary>
            /// Repository specific configuration file; $WORK_DIR/.git/config on
            /// non-bare repos
            /// </summary>
            GIT_CONFIG_LEVEL_LOCAL = (int)5,
            
            /// <summary>
            /// Application specific configuration file; freely defined by applications
            /// </summary>
            GIT_CONFIG_LEVEL_APP = (int)6,
            
            /// <summary>
            /// Represents the highest level available config file (i.e. the most
            /// specific config file available that actually is loaded)
            /// </summary>
            GIT_CONFIG_HIGHEST_LEVEL = (int)-1,
        }
        
        /// <summary>
        /// System-wide on Windows, for compatibility with portable git
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_PROGRAMDATA = git_config_level_t.GIT_CONFIG_LEVEL_PROGRAMDATA;
        
        /// <summary>
        /// System-wide configuration file; /etc/gitconfig on Linux systems
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_SYSTEM = git_config_level_t.GIT_CONFIG_LEVEL_SYSTEM;
        
        /// <summary>
        /// XDG compatible configuration file; typically ~/.config/git/config
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_XDG = git_config_level_t.GIT_CONFIG_LEVEL_XDG;
        
        /// <summary>
        /// User-specific configuration file (also called Global configuration
        /// file); typically ~/.gitconfig
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_GLOBAL = git_config_level_t.GIT_CONFIG_LEVEL_GLOBAL;
        
        /// <summary>
        /// Repository specific configuration file; $WORK_DIR/.git/config on
        /// non-bare repos
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_LOCAL = git_config_level_t.GIT_CONFIG_LEVEL_LOCAL;
        
        /// <summary>
        /// Application specific configuration file; freely defined by applications
        /// </summary>
        public const git_config_level_t GIT_CONFIG_LEVEL_APP = git_config_level_t.GIT_CONFIG_LEVEL_APP;
        
        /// <summary>
        /// Represents the highest level available config file (i.e. the most
        /// specific config file available that actually is loaded)
        /// </summary>
        public const git_config_level_t GIT_CONFIG_HIGHEST_LEVEL = git_config_level_t.GIT_CONFIG_HIGHEST_LEVEL;
        
        /// <summary>
        /// Config var type
        /// </summary>
        public enum git_cvar_t : int
        {
            GIT_CVAR_FALSE = (int)0,
            
            GIT_CVAR_TRUE = (int)1,
            
            GIT_CVAR_INT32,
            
            GIT_CVAR_STRING,
        }
        
        public const git_cvar_t GIT_CVAR_FALSE = git_cvar_t.GIT_CVAR_FALSE;
        
        public const git_cvar_t GIT_CVAR_TRUE = git_cvar_t.GIT_CVAR_TRUE;
        
        public const git_cvar_t GIT_CVAR_INT32 = git_cvar_t.GIT_CVAR_INT32;
        
        public const git_cvar_t GIT_CVAR_STRING = git_cvar_t.GIT_CVAR_STRING;
        
        /// <summary>
        /// An entry in a configuration file
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_config_entry
        {
            /// <summary>
            /// Name of the entry (normalised)
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string name;
            
            /// <summary>
            /// String value of the entry
            /// </summary>
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerRelaxedNoCleanup))]
            public string value;
            
            /// <summary>
            /// Depth of includes where this variable was found
            /// </summary>
            public uint include_depth;
            
            /// <summary>
            /// Which config file this was found in
            /// </summary>
            public git_config_level_t level;
            
            public free_delegate free;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void free_delegate(ref git_config_entry entry);
            
            /// <summary>
            /// Opaque value for the free function. Do not read or write
            /// </summary>
            public IntPtr payload;
        }
        
        /// <summary>
        /// An opaque structure for a configuration iterator
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_config_iterator : IEquatable<git_config_iterator>
        {
            private readonly IntPtr _handle;
            
            public git_config_iterator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_config_iterator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_config_iterator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_config_iterator left, git_config_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_config_iterator left, git_config_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Mapping from config variables to values.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_cvar_map
        {
            public git_cvar_t cvar_type;
            
            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))]
            public string str_match;
            
            public int map_value;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_config_foreach_cb(in git_config_entry entry, IntPtr payload);
        
        /// <summary>
        /// Free a config entry
        /// </summary>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_config_entry_free(ref git_config_entry arg0);
        
        /// <summary>
        /// Locate the path to the global configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>0 if a global configuration file has been found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// The user or global configuration file is usually
        /// located in `$HOME/.gitconfig`.This method will try to guess the full path to that
        /// file, if the file exists. The returned path
        /// may be used on any `git_config` call to load the
        /// global configuration file.This method will not guess the path to the xdg compatible
        /// config file (.config/git/config).
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_find_global(out git_buf @out);
        
        /// <summary>
        /// Locate the path to the global xdg compatible configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>0 if a xdg compatible configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// The xdg compatible configuration file is usually
        /// located in `$HOME/.config/git/config`.This method will try to guess the full path to that
        /// file, if the file exists. The returned path
        /// may be used on any `git_config` call to load the
        /// xdg compatible configuration file.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_find_xdg(out git_buf @out);
        
        /// <summary>
        /// Locate the path to the system configuration file
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>0 if a system configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// If /etc/gitconfig doesn't exist, it will look for
        /// %PROGRAMFILES%@Git @etc @gitconfig .
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_find_system(out git_buf @out);
        
        /// <summary>
        /// Locate the path to the configuration file in ProgramData
        /// </summary>
        /// <param name="out">Pointer to a user-allocated git_buf in which to store the path</param>
        /// <returns>0 if a ProgramData configuration file has been
        /// found. Its path will be stored in `out`.</returns>
        /// <remarks>
        /// Look for the file in %PROGRAMDATA%@Git @config used by portable git.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_find_programdata(out git_buf @out);
        
        /// <summary>
        /// Open the global, XDG and system configuration files
        /// </summary>
        /// <param name="out">Pointer to store the config instance</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Utility wrapper that finds the global, XDG and system configuration files
        /// and opens them into a single prioritized config object that can be
        /// used when accessing default config data outside a repository.
        /// </remarks>
        public static git_result git_config_open_default(out git_config @out)
        {
            var __result__ = git_config_open_default__(out @out).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_open_default", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_open_default__(out git_config @out);
        
        /// <summary>
        /// Allocate a new configuration object
        /// </summary>
        /// <param name="out">pointer to the new configuration</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This object is empty, so you have to add a file to it before you
        /// can do anything with it.
        /// </remarks>
        public static git_result git_config_new(out git_config @out)
        {
            var __result__ = git_config_new__(out @out).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_new__(out git_config @out);
        
        /// <summary>
        /// Add an on-disk config file instance to an existing config
        /// </summary>
        /// <param name="cfg">the configuration to add the file to</param>
        /// <param name="path">path to the configuration file to add</param>
        /// <param name="level">the priority level of the backend</param>
        /// <param name="force">replace config file at the given priority level</param>
        /// <param name="repo">optional repository to allow parsing of
        /// conditional includes</param>
        /// <returns>0 on success, GIT_EEXISTS when adding more than one file
        /// for a given priority level (and force_replace set to 0),
        /// GIT_ENOTFOUND when the file doesn't exist or error code</returns>
        /// <remarks>
        /// The on-disk file pointed at by `path` will be opened and
        /// parsed; it's expected to be a native Git config file following
        /// the default Git config syntax (see man git-config).If the file does not exist, the file will still be added and it
        /// will be created the first time we write to it.Note that the configuration object will free the file
        /// automatically.Further queries on this config object will access each
        /// of the config file instances in order (instances with
        /// a higher priority level will be accessed first).
        /// </remarks>
        public static git_result git_config_add_file_ondisk(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_config_level_t level, git_repository repo, int force)
        {
            var __result__ = git_config_add_file_ondisk__(cfg, path, level, repo, force).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_add_file_ondisk", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_add_file_ondisk__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path, git_config_level_t level, git_repository repo, int force);
        
        /// <summary>
        /// Create a new config instance containing a single on-disk file
        /// </summary>
        /// <param name="out">The configuration instance to create</param>
        /// <param name="path">Path to the on-disk file to open</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// This method is a simple utility wrapper for the following sequence
        /// of calls:
        /// - git_config_new
        /// - git_config_add_file_ondisk
        /// </remarks>
        public static git_result git_config_open_ondisk(out git_config @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path)
        {
            var __result__ = git_config_open_ondisk__(out @out, path).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_open_ondisk", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_open_ondisk__(out git_config @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string path);
        
        /// <summary>
        /// Build a single-level focused config object from a multi-level one.
        /// </summary>
        /// <param name="out">The configuration instance to create</param>
        /// <param name="parent">Multi-level config to search for the given level</param>
        /// <param name="level">Configuration level to search for</param>
        /// <returns>0, GIT_ENOTFOUND if the passed level cannot be found in the
        /// multi-level parent config, or an error code</returns>
        /// <remarks>
        /// The returned config object can be used to perform get/set/delete operations
        /// on a single specific level.Getting several times the same level from the same parent multi-level config
        /// will return different config instances, but containing the same config_file
        /// instance.
        /// </remarks>
        public static git_result git_config_open_level(out git_config @out, git_config parent, git_config_level_t level)
        {
            var __result__ = git_config_open_level__(out @out, parent, level).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_open_level", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_open_level__(out git_config @out, git_config parent, git_config_level_t level);
        
        /// <summary>
        /// Open the global/XDG configuration file according to git's rules
        /// </summary>
        /// <param name="out">pointer in which to store the config object</param>
        /// <param name="config">the config object in which to look</param>
        /// <remarks>
        /// Git allows you to store your global configuration at
        /// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
        /// compatability, the XDG file shouldn't be used unless the use has
        /// created it explicitly. With this function you'll open the correct
        /// one to write to.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_open_global(out git_config @out, git_config config);
        
        /// <summary>
        /// Create a snapshot of the configuration
        /// </summary>
        /// <param name="out">pointer in which to store the snapshot config object</param>
        /// <param name="config">configuration to snapshot</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Create a snapshot of the current state of a configuration, which
        /// allows you to look into a consistent view of the configuration for
        /// looking up complex values (e.g. a remote, submodule).The string returned when querying such a config object is valid
        /// until it is freed.
        /// </remarks>
        public static git_result git_config_snapshot(out git_config @out, git_config config)
        {
            var __result__ = git_config_snapshot__(out @out, config).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_snapshot", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_snapshot__(out git_config @out, git_config config);
        
        /// <summary>
        /// Free the configuration and its associated memory and files
        /// </summary>
        /// <param name="cfg">the configuration to free</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_config_free(git_config cfg);
        
        /// <summary>
        /// Get the git_config_entry of a config variable.
        /// </summary>
        /// <param name="out">pointer to the variable git_config_entry</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Free the git_config_entry after use with `git_config_entry_free()`.
        /// </remarks>
        public static git_result git_config_get_entry(out IntPtr @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_entry__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_entry", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_entry__(out IntPtr @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of an integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_int32(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_int32__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_int32", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_int32__(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of a long integer config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_int64(out long @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_int64__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_int64", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_int64__(out long @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of a boolean config variable.
        /// </summary>
        /// <param name="out">pointer to the variable where the value should be stored</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This function uses the usual C convention of 0 being false and
        /// anything else true.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_bool(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_bool__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_bool", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_bool__(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of a path config variable.
        /// </summary>
        /// <param name="out">the buffer in which to store the result</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_path(out git_buf @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_path__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_path", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_path__(out git_buf @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">pointer to the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This function can only be used on snapshot config objects. The
        /// string is owned by the config and should not be freed by the
        /// user. The pointer will be valid until the config is freed.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_string(out string @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_string__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_string", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_string__(out string @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get the value of a string config variable.
        /// </summary>
        /// <param name="out">buffer in which to store the string</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The value of the config will be copied into the buffer.All config files will be looked into, in the order of their
        /// defined level. A higher level means a higher priority. The
        /// first occurrence of the variable will be returned here.
        /// </remarks>
        public static git_result git_config_get_string_buf(out git_buf @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name)
        {
            var __result__ = git_config_get_string_buf__(out @out, cfg, name).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_string_buf", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_string_buf__(out git_buf @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Get each value of a multivar in a foreach callback
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <param name="callback">the function to be called on each value of the variable</param>
        /// <param name="payload">opaque pointer to pass to the callback</param>
        /// <remarks>
        /// The callback will be called on each variable foundThe regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_get_multivar_foreach(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp, git_config_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Get each value of a multivar
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">regular expression to filter which variables we're
        /// interested in. Use NULL to indicate all</param>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_multivar_iterator_new(out git_config_iterator @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp);
        
        /// <summary>
        /// Return the current entry and advance the iterator
        /// </summary>
        /// <param name="entry">pointer to store the entry</param>
        /// <param name="iter">the iterator</param>
        /// <returns>0 or an error code. GIT_ITEROVER if the iteration has completed</returns>
        /// <remarks>
        /// The pointers returned by this function are valid until the iterator
        /// is freed.
        /// </remarks>
        public static git_result git_config_next(out IntPtr entry, git_config_iterator iter)
        {
            var __result__ = git_config_next__(out entry, iter).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_next", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_next__(out IntPtr entry, git_config_iterator iter);
        
        /// <summary>
        /// Free a config iterator
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_config_iterator_free(git_config_iterator iter);
        
        /// <summary>
        /// Set the value of an integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Integer value for the variable</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_config_set_int32(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, int value)
        {
            var __result__ = git_config_set_int32__(cfg, name, value).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_set_int32", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_set_int32__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, int value);
        
        /// <summary>
        /// Set the value of a long integer config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">Long integer value for the variable</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_config_set_int64(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, long value)
        {
            var __result__ = git_config_set_int64__(cfg, name, value).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_set_int64", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_set_int64__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, long value);
        
        /// <summary>
        /// Set the value of a boolean config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the value to store</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_config_set_bool(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, int value)
        {
            var __result__ = git_config_set_bool__(cfg, name, value).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_set_bool", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_set_bool__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, int value);
        
        /// <summary>
        /// Set the value of a string config variable in the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="value">the string to store.</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// A copy of the string is made and the user is free to use it
        /// afterwards.
        /// </remarks>
        public static git_result git_config_set_string(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value)
        {
            var __result__ = git_config_set_string__(cfg, name, value).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_set_string", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_set_string__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Set a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variable</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to replace</param>
        /// <param name="value">the new value.</param>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_set_multivar(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Delete a config variable from the config file
        /// with the highest level (usually the local one).
        /// </summary>
        /// <param name="cfg">the configuration</param>
        /// <param name="name">the variable to delete</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_delete_entry(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name);
        
        /// <summary>
        /// Deletes one or several entries from a multivar in the local config file.
        /// </summary>
        /// <param name="cfg">where to look for the variables</param>
        /// <param name="name">the variable's name</param>
        /// <param name="regexp">a regular expression to indicate which values to delete</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The regular expression is applied case-sensitively on the value.
        /// </remarks>
        public static git_result git_config_delete_multivar(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp)
        {
            var __result__ = git_config_delete_multivar__(cfg, name, regexp).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_delete_multivar", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_delete_multivar__(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp);
        
        /// <summary>
        /// Perform an operation on each config variable.
        /// </summary>
        /// <param name="cfg">where to get the variables from</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The callback receives the normalized name and value of each variable
        /// in the config backend, and the data pointer passed to this function.
        /// If the callback returns a non-zero value, the function stops iterating
        /// and returns that value to the caller.The pointers passed to the callback are only valid as long as the
        /// iteration is ongoing.
        /// </remarks>
        public static git_result git_config_foreach(git_config cfg, git_config_foreach_cb callback, IntPtr payload)
        {
            var __result__ = git_config_foreach__(cfg, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_foreach__(git_config cfg, git_config_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Iterate over all the config variables
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to ge the variables from</param>
        /// <remarks>
        /// Use `git_config_next` to advance the iteration and
        /// `git_config_iterator_free` when done.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_iterator_new(out git_config_iterator @out, git_config cfg);
        
        /// <summary>
        /// Iterate over all the config variables whose name matches a pattern
        /// </summary>
        /// <param name="out">pointer to store the iterator</param>
        /// <param name="cfg">where to ge the variables from</param>
        /// <param name="regexp">regular expression to match the names</param>
        /// <remarks>
        /// Use `git_config_next` to advance the iteration and
        /// `git_config_iterator_free` when done.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_iterator_glob_new(out git_config_iterator @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp);
        
        /// <summary>
        /// Perform an operation on each config variable matching a regular expression.
        /// </summary>
        /// <param name="cfg">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <returns>0 or the return value of the callback which didn't return 0</returns>
        /// <remarks>
        /// This behaves like `git_config_foreach` with an additional filter of a
        /// regular expression that filters which config keys are passed to the
        /// callback.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the case-insensitive parts are lower-case.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_foreach_match(git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp, git_config_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Query the value of a config variable and return it mapped to
        /// an integer constant.
        /// </summary>
        /// <param name="out">place to store the result of the mapping</param>
        /// <param name="cfg">config file to get the variables from</param>
        /// <param name="name">name of the config variable to lookup</param>
        /// <param name="maps">array of `git_cvar_map` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <returns>0 on success, error code otherwise</returns>
        /// <remarks>
        /// This is a helper method to easily map different possible values
        /// to a variable to integer constants that easily identify them.A mapping array looks as follows:git_cvar_map autocrlf_mapping[] = {
        /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
        /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
        /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
        /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
        /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.The same thing applies for any "true" value such as "true", "yes" or "1", storing
        /// the `GIT_AUTO_CRLF_TRUE` variable.Otherwise, if the value matches the string "input" (with case insensitive comparison),
        /// the given constant will be stored in `out`, and likewise for "default".If not a single match can be made to store in `out`, an error code will be
        /// returned.
        /// </remarks>
        public static git_result git_config_get_mapped(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, in git_cvar_map maps, size_t map_n)
        {
            var __result__ = git_config_get_mapped__(out @out, cfg, name, maps, map_n).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_get_mapped", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_get_mapped__(out int @out, git_config cfg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string name, in git_cvar_map maps, size_t map_n);
        
        /// <summary>
        /// Maps a string value to an integer constant
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="maps">array of `git_cvar_map` objects specifying the possible mappings</param>
        /// <param name="map_n">number of mapping objects in `maps`</param>
        /// <param name="value">value to parse</param>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_lookup_map_value(out int @out, in git_cvar_map maps, size_t map_n, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Parse a string value as a bool.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <remarks>
        /// Valid values for true are: 'true', 'yes', 'on', 1 or any
        /// number different from 0
        /// Valid values for false are: 'false', 'no', 'off', 0
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_parse_bool(out int @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Parse a string value as an int32.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_parse_int32(out int @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Parse a string value as an int64.
        /// </summary>
        /// <param name="out">place to store the result of the parsing</param>
        /// <param name="value">value to parse</param>
        /// <remarks>
        /// An optional value suffix of 'k', 'm', or 'g' will
        /// cause the value to be multiplied by 1024, 1048576,
        /// or 1073741824 prior to output.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_parse_int64(out long @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Parse a string value as a path.
        /// </summary>
        /// <param name="out">placae to store the result of parsing</param>
        /// <param name="value">the path to evaluate</param>
        /// <remarks>
        /// A leading '~' will be expanded to the global search path (which
        /// defaults to the user's home directory but can be overridden via
        /// `git_libgit2_opts()`.If the value does not begin with a tilde, the input will be
        /// returned.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_parse_path(out git_buf @out, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string value);
        
        /// <summary>
        /// Perform an operation on each config variable in a given config backend,
        /// matching a regular expression.
        /// </summary>
        /// <param name="backend">where to get the variables from</param>
        /// <param name="regexp">regular expression to match against config names (can be NULL)</param>
        /// <param name="callback">the function to call on each variable</param>
        /// <param name="payload">the data to pass to the callback</param>
        /// <remarks>
        /// This behaves like `git_config_foreach_match` except that only config
        /// entries from the given backend entry are enumerated.The regular expression is applied case-sensitively on the normalized form of
        /// the variable name: the section and variable parts are lower-cased. The
        /// subsection is left unchanged.
        /// </remarks>
        [DllImport(GitLibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_config_backend_foreach_match(git_config_backend backend, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(UTF8MarshallerStrict))] string regexp, git_config_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Lock the backend with the highest priority
        /// </summary>
        /// <param name="tx">the resulting transaction, use this to commit or undo the
        /// changes</param>
        /// <param name="cfg">the configuration in which to lock</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Locking disallows anybody else from writing to that backend. Any
        /// updates made after locking will not be visible to a reader until
        /// the file is unlocked.You can apply the changes by calling `git_transaction_commit()`
        /// before freeing the transaction. Either of these actions will unlock
        /// the config.
        /// </remarks>
        public static git_result git_config_lock(out git_transaction tx, git_config cfg)
        {
            var __result__ = git_config_lock__(out tx, cfg).Check();
            return __result__;
        }
        
        [DllImport(GitLibName, EntryPoint = "git_config_lock", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_config_lock__(out git_transaction tx, git_config cfg);
    }
}
