//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Normalization options for reference lookup
        /// </summary>
        [Flags]
        public enum git_reference_format_t : int
        {
            /// <summary>
            /// No particular normalization.
            /// </summary>
            GIT_REFERENCE_FORMAT_NORMAL = (int)0u,
            
            /// <summary>
            /// Control whether one-level refnames are accepted
            /// (i.e., refnames that do not contain multiple /-separated
            /// components). Those are expected to be written only using
            /// uppercase letters and underscore (FETCH_HEAD, ...)
            /// </summary>
            GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = (int)(1u<<0),
            
            /// <summary>
            /// Interpret the provided name as a reference pattern for a
            /// refspec (as used with remote repositories). If this option
            /// is enabled, the name is allowed to contain a single * (
            /// &lt;star
            /// &gt;)
            /// in place of a one full pathname component
            /// (e.g., foo/
            /// &lt;star
            /// &gt;/bar but not foo/bar
            /// &lt;star
            /// &gt;).
            /// </summary>
            GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = (int)(1u<<1),
            
            /// <summary>
            /// Interpret the name as part of a refspec in shorthand form
            /// so the `ONELEVEL` naming rules aren't enforced and 'master'
            /// becomes a valid name.
            /// </summary>
            GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = (int)(1u<<2),
        }
        
        /// <summary>
        /// No particular normalization.
        /// </summary>
        public const git_reference_format_t GIT_REFERENCE_FORMAT_NORMAL = git_reference_format_t.GIT_REFERENCE_FORMAT_NORMAL;
        
        /// <summary>
        /// Control whether one-level refnames are accepted
        /// (i.e., refnames that do not contain multiple /-separated
        /// components). Those are expected to be written only using
        /// uppercase letters and underscore (FETCH_HEAD, ...)
        /// </summary>
        public const git_reference_format_t GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = git_reference_format_t.GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL;
        
        /// <summary>
        /// Interpret the provided name as a reference pattern for a
        /// refspec (as used with remote repositories). If this option
        /// is enabled, the name is allowed to contain a single * (
        /// &lt;star
        /// &gt;)
        /// in place of a one full pathname component
        /// (e.g., foo/
        /// &lt;star
        /// &gt;/bar but not foo/bar
        /// &lt;star
        /// &gt;).
        /// </summary>
        public const git_reference_format_t GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = git_reference_format_t.GIT_REFERENCE_FORMAT_REFSPEC_PATTERN;
        
        /// <summary>
        /// Interpret the name as part of a refspec in shorthand form
        /// so the `ONELEVEL` naming rules aren't enforced and 'master'
        /// becomes a valid name.
        /// </summary>
        public const git_reference_format_t GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = git_reference_format_t.GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND;
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_reference_foreach_cb(git_reference reference, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_reference_foreach_name_cb([MarshalAs(UnmanagedType.LPUTF8Str)] string name, IntPtr payload);
        
        /// <summary>
        /// Lookup a reference by name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up reference</param>
        /// <param name="repo">the repository to look up the reference</param>
        /// <param name="name">the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The returned reference must be freed by the user.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_reference_lookup(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name)
        {
            var __result__ = git_reference_lookup__(out @out, repo, name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_lookup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_lookup__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Lookup a reference by name and resolve immediately to OID.
        /// </summary>
        /// <param name="out">Pointer to oid to be filled in</param>
        /// <param name="repo">The repository in which to look up the reference</param>
        /// <param name="name">The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)</param>
        /// <returns>0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// This function provides a quick way to resolve a reference name straight
        /// through to the object id that it refers to.  This avoids having to
        /// allocate or free any `git_reference` objects for simple situations.The name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_reference_name_to_id(out git_oid @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name)
        {
            var __result__ = git_reference_name_to_id__(out @out, repo, name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_name_to_id", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_name_to_id__(out git_oid @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Lookup a reference by DWIMing its short name
        /// </summary>
        /// <param name="out">pointer in which to store the reference</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="shorthand">the short name for the reference</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Apply the git precendence rules to the given shorthand to determine
        /// which reference the user is referring to.
        /// </remarks>
        public static git_result git_reference_dwim(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string shorthand)
        {
            var __result__ = git_reference_dwim__(out @out, repo, shorthand).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_dwim", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_dwim__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string shorthand);
        
        /// <summary>
        /// Conditionally create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_value">The expected value of the reference when updating</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "
        /// @
        /// {" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_value`
        /// (i.e. if the ref has changed since the user read it).
        /// </remarks>
        public static git_result git_reference_symbolic_create_matching(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string current_value, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_symbolic_create_matching__(out @out, repo, name, target, force, current_value, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_symbolic_create_matching", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_symbolic_create_matching__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string current_value, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Create a new symbolic reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="target">The target of the reference</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A symbolic reference is a reference name that refers to another
        /// reference name.  If the other name moves, the symbolic name will move,
        /// too.  As a simple example, the "HEAD" reference might refer to
        /// "refs/heads/master" while on the "master" branch of a repository.The symbolic reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "
        /// @
        /// {" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and it does not have a reflog.
        /// </remarks>
        public static git_result git_reference_symbolic_create(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_symbolic_create__(out @out, repo, name, target, force, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_symbolic_create", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_symbolic_create__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Create a new direct reference.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "
        /// @
        /// {" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and and it does not have a reflog.
        /// </remarks>
        public static git_result git_reference_create(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, in git_oid id, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_create__(out @out, repo, name, id, force, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_create", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_create__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, in git_oid id, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Conditionally create new direct reference
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="repo">Repository where that reference will live</param>
        /// <param name="name">The name of the reference</param>
        /// <param name="id">The object id pointed to by the reference.</param>
        /// <param name="force">Overwrite existing references</param>
        /// <param name="current_id">The expected value of the reference at the time of update</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// A direct reference (also called an object id reference) refers directly
        /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
        /// permanently refers to the object (although the reference itself can be
        /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
        /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.The direct reference will be created in the repository and written to
        /// the disk.  The generated reference object must be freed by the user.Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "
        /// @
        /// {" which have special meaning to revparse.This function will return an error if a reference already exists with the
        /// given name unless `force` is true, in which case it will be overwritten.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and and it does not have a reflog.It will return GIT_EMODIFIED if the reference's value at the time
        /// of updating does not match the one passed through `current_id`
        /// (i.e. if the ref has changed since the user read it).
        /// </remarks>
        public static git_result git_reference_create_matching(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, in git_oid id, int force, in git_oid current_id, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_create_matching__(out @out, repo, name, id, force, current_id, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_create_matching", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_create_matching__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, in git_oid id, int force, in git_oid current_id, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Get the OID pointed to by a direct reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>a pointer to the oid if available, NULL otherwise</returns>
        /// <remarks>
        /// Only available if the reference is direct (i.e. an object id reference,
        /// not a symbolic one).To find the OID of a symbolic ref, call `git_reference_resolve()` and
        /// then this function (or maybe use `git_reference_name_to_id()` to
        /// directly resolve a reference name all the way through to an OID).
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_reference_target(git_reference @ref);
        
        /// <summary>
        /// Return the peeled OID target of this reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>a pointer to the oid if available, NULL otherwise</returns>
        /// <remarks>
        /// This peeled OID only applies to direct references that point to
        /// a hard Tag object: it is the result of peeling such Tag.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_reference_target_peel(git_reference @ref);
        
        /// <summary>
        /// Get full name to the reference pointed to by a symbolic reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>a pointer to the name if available, NULL otherwise</returns>
        /// <remarks>
        /// Only available if the reference is symbolic.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_reference_symbolic_target(git_reference @ref);
        
        /// <summary>
        /// Get the type of a reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>the type</returns>
        /// <remarks>
        /// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_reference_t git_reference_type(git_reference @ref);
        
        /// <summary>
        /// Get the full name of a reference.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>the full name for the ref</returns>
        /// <remarks>
        /// See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_reference_name(git_reference @ref);
        
        /// <summary>
        /// Resolve a symbolic reference to a direct reference.
        /// </summary>
        /// <param name="out">Pointer to the peeled reference</param>
        /// <param name="ref">The reference</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This method iteratively peels a symbolic reference until it resolves to
        /// a direct reference to an OID.The peeled reference is returned in the `resolved_ref` argument, and
        /// must be freed manually once it's no longer needed.If a direct reference is passed as an argument, a copy of that
        /// reference is returned. This copy must be manually freed too.
        /// </remarks>
        public static git_result git_reference_resolve(out git_reference @out, git_reference @ref)
        {
            var __result__ = git_reference_resolve__(out @out, @ref).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_resolve", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_resolve__(out git_reference @out, git_reference @ref);
        
        /// <summary>
        /// Get the repository where a reference resides.
        /// </summary>
        /// <param name="ref">The reference</param>
        /// <returns>a pointer to the repo</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_reference_owner(git_reference @ref);
        
        /// <summary>
        /// Create a new reference with the same name as the given reference but a
        /// different symbolic target. The reference must be a symbolic reference,
        /// otherwise this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="target">The new target for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.The target name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.The message for the reflog will be ignored if the reference does
        /// not belong in the standard set (HEAD, branches and remote-tracking
        /// branches) and and it does not have a reflog.
        /// </remarks>
        public static git_result git_reference_symbolic_set_target(out git_reference @out, git_reference @ref, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_symbolic_set_target__(out @out, @ref, target, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_symbolic_set_target", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_symbolic_set_target__(out git_reference @out, git_reference @ref, [MarshalAs(UnmanagedType.LPUTF8Str)] string target, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Conditionally create a new reference with the same name as the given reference but a
        /// different OID target. The reference must be a direct reference, otherwise
        /// this will fail.
        /// </summary>
        /// <param name="out">Pointer to the newly created reference</param>
        /// <param name="ref">The reference</param>
        /// <param name="id">The new target OID for the reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EMODIFIED if the value of the reference
        /// has changed since it was read, or an error code</returns>
        /// <remarks>
        /// The new reference will be written to disk, overwriting the given reference.
        /// </remarks>
        public static git_result git_reference_set_target(out git_reference @out, git_reference @ref, in git_oid id, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_set_target__(out @out, @ref, id, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_set_target", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_set_target__(out git_reference @out, git_reference @ref, in git_oid id, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Rename an existing reference.
        /// </summary>
        /// <param name="ref">The reference to rename</param>
        /// <param name="new_name">The new name for the reference</param>
        /// <param name="force">Overwrite an existing reference</param>
        /// <param name="log_message">The one line long message to be appended to the reflog</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This method works for both direct and symbolic references.The new name will be checked for validity.
        /// See `git_reference_symbolic_create()` for rules about valid names.If the `force` flag is not enabled, and there's already
        /// a reference with the given name, the renaming will fail.IMPORTANT:
        /// The user needs to write a proper reflog entry if the
        /// reflog is enabled for the repository. We only rename
        /// the reflog if it exists.
        /// </remarks>
        public static git_result git_reference_rename(out git_reference new_ref, git_reference @ref, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_name, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message)
        {
            var __result__ = git_reference_rename__(out new_ref, @ref, new_name, force, log_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_rename", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_rename__(out git_reference new_ref, git_reference @ref, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_name, int force, [MarshalAs(UnmanagedType.LPUTF8Str)] string log_message);
        
        /// <summary>
        /// Delete an existing reference.
        /// </summary>
        /// <param name="ref">The reference to remove</param>
        /// <returns>0, GIT_EMODIFIED or an error code</returns>
        /// <remarks>
        /// This method works for both direct and symbolic references.  The reference
        /// will be immediately removed on disk but the memory will not be freed.
        /// Callers must call `git_reference_free`.This function will return an error if the reference has changed
        /// from the time it was looked up.
        /// </remarks>
        public static git_result git_reference_delete(git_reference @ref)
        {
            var __result__ = git_reference_delete__(@ref).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_delete", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_delete__(git_reference @ref);
        
        /// <summary>
        /// Delete an existing reference by name
        /// </summary>
        /// <param name="name">The reference to remove</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// This method removes the named reference from the repository without
        /// looking at its old value.
        /// </remarks>
        public static git_result git_reference_remove(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name)
        {
            var __result__ = git_reference_remove__(repo, name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_remove", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_remove__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Fill a list with all the references that can be found in a repository.
        /// </summary>
        /// <param name="array">Pointer to a git_strarray structure where
        /// the reference names will be stored</param>
        /// <param name="repo">Repository where to find the refs</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The string array will be filled with the names of all references; these
        /// values are owned by the user and should be free'd manually when no
        /// longer needed, using `git_strarray_free()`.
        /// </remarks>
        public static git_result git_reference_list(out string[] array, git_repository repo)
        {
            git_strarray array__;
            var __result__ = git_reference_list__(out array__, repo).Check();
            array = array__.ToArray();
            git_strarray_free(ref array__);
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_list", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_list__(out git_strarray array, git_repository repo);
        
        /// <summary>
        /// Perform a callback on each reference in the repository.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="callback">Function which will be called for every listed ref</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The `callback` function will be called for each reference in the
        /// repository, receiving the reference object and the `payload` value
        /// passed to this method.  Returning a non-zero value from the callback
        /// will terminate the iteration.Note that the callback function is responsible to call `git_reference_free`
        /// on each reference passed to it.
        /// </remarks>
        public static git_result git_reference_foreach(git_repository repo, git_reference_foreach_cb callback, IntPtr payload)
        {
            var __result__ = git_reference_foreach__(repo, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_foreach__(git_repository repo, git_reference_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Perform a callback on the fully-qualified name of each reference.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="callback">Function which will be called for every listed ref name</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        /// <remarks>
        /// The `callback` function will be called for each reference in the
        /// repository, receiving the name of the reference and the `payload` value
        /// passed to this method.  Returning a non-zero value from the callback
        /// will terminate the iteration.
        /// </remarks>
        public static git_result git_reference_foreach_name(git_repository repo, git_reference_foreach_name_cb callback, IntPtr payload)
        {
            var __result__ = git_reference_foreach_name__(repo, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_foreach_name", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_foreach_name__(git_repository repo, git_reference_foreach_name_cb callback, IntPtr payload);
        
        /// <summary>
        /// Create a copy of an existing reference.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="source">object to copy</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Call `git_reference_free` to free the data.
        /// </remarks>
        public static git_result git_reference_dup(out git_reference dest, git_reference source)
        {
            var __result__ = git_reference_dup__(out dest, source).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_dup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_dup__(out git_reference dest, git_reference source);
        
        /// <summary>
        /// Free the given reference.
        /// </summary>
        /// <param name="ref">git_reference</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_reference_free(git_reference @ref);
        
        /// <summary>
        /// Compare two references.
        /// </summary>
        /// <param name="ref1">The first git_reference</param>
        /// <param name="ref2">The second git_reference</param>
        /// <returns>0 if the same, else a stable but meaningless ordering.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_cmp(git_reference ref1, git_reference ref2);
        
        /// <summary>
        /// Create an iterator for the repo's references
        /// </summary>
        /// <param name="out">pointer in which to store the iterator</param>
        /// <param name="repo">the repository</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_reference_iterator_new(out git_reference_iterator @out, git_repository repo)
        {
            var __result__ = git_reference_iterator_new__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_iterator_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_iterator_new__(out git_reference_iterator @out, git_repository repo);
        
        /// <summary>
        /// Create an iterator for the repo's references that match the
        /// specified glob
        /// </summary>
        /// <param name="out">pointer in which to store the iterator</param>
        /// <param name="repo">the repository</param>
        /// <param name="glob">the glob to match against the reference names</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_reference_iterator_glob_new(out git_reference_iterator @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string glob)
        {
            var __result__ = git_reference_iterator_glob_new__(out @out, repo, glob).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_iterator_glob_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_iterator_glob_new__(out git_reference_iterator @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string glob);
        
        /// <summary>
        /// Get the next reference
        /// </summary>
        /// <param name="out">pointer in which to store the reference</param>
        /// <param name="iter">the iterator</param>
        /// <returns>0, GIT_ITEROVER if there are no more; or an error code</returns>
        public static git_result git_reference_next(out git_reference @out, git_reference_iterator iter)
        {
            var __result__ = git_reference_next__(out @out, iter).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_next", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_next__(out git_reference @out, git_reference_iterator iter);
        
        /// <summary>
        /// Get the next reference's name
        /// </summary>
        /// <param name="out">pointer in which to store the string</param>
        /// <param name="iter">the iterator</param>
        /// <returns>0, GIT_ITEROVER if there are no more; or an error code</returns>
        /// <remarks>
        /// This function is provided for convenience in case only the names
        /// are interesting as it avoids the allocation of the `git_reference`
        /// object which `git_reference_next()` needs.
        /// </remarks>
        public static git_result git_reference_next_name(out string @out, git_reference_iterator iter)
        {
            var __result__ = git_reference_next_name__(out @out, iter).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_next_name", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_next_name__(out string @out, git_reference_iterator iter);
        
        /// <summary>
        /// Free the iterator and its associated resources
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_reference_iterator_free(git_reference_iterator iter);
        
        /// <summary>
        /// Perform a callback on each reference in the repository whose name
        /// matches the given pattern.
        /// </summary>
        /// <param name="repo">Repository where to find the refs</param>
        /// <param name="glob">Pattern to match (fnmatch-style) against reference name.</param>
        /// <param name="callback">Function which will be called for every listed ref</param>
        /// <param name="payload">Additional data to pass to the callback</param>
        /// <returns>0 on success, GIT_EUSER on non-zero callback, or error code</returns>
        /// <remarks>
        /// This function acts like `git_reference_foreach()` with an additional
        /// pattern match being applied to the reference name before issuing the
        /// callback function.  See that function for more information.The pattern is matched using fnmatch or "glob" style where a '*' matches
        /// any sequence of letters, a '?' matches any letter, and square brackets
        /// can be used to define character ranges (such as "[0-9]" for digits).
        /// </remarks>
        public static git_result git_reference_foreach_glob(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string glob, git_reference_foreach_name_cb callback, IntPtr payload)
        {
            var __result__ = git_reference_foreach_glob__(repo, glob, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_foreach_glob", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_foreach_glob__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string glob, git_reference_foreach_name_cb callback, IntPtr payload);
        
        /// <summary>
        /// Check if a reflog exists for the specified reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>0 when no reflog can be found, 1 when it exists;
        /// otherwise an error code.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_has_log(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname);
        
        /// <summary>
        /// Ensure there is a reflog for a particular reference.
        /// </summary>
        /// <param name="repo">the repository</param>
        /// <param name="refname">the reference's name</param>
        /// <returns>0 or an error code.</returns>
        /// <remarks>
        /// Make sure that successive updates to the reference will append to
        /// its log.
        /// </remarks>
        public static git_result git_reference_ensure_log(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname)
        {
            var __result__ = git_reference_ensure_log__(repo, refname).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_ensure_log", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_ensure_log__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname);
        
        /// <summary>
        /// Check if a reference is a local branch.
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>1 when the reference lives in the refs/heads
        /// namespace; 0 otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_is_branch(git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a remote tracking branch
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>1 when the reference lives in the refs/remotes
        /// namespace; 0 otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_is_remote(git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a tag
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>1 when the reference lives in the refs/tags
        /// namespace; 0 otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_is_tag(git_reference @ref);
        
        /// <summary>
        /// Check if a reference is a note
        /// </summary>
        /// <param name="ref">A git reference</param>
        /// <returns>1 when the reference lives in the refs/notes
        /// namespace; 0 otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_is_note(git_reference @ref);
        
        /// <summary>
        /// Normalize reference name and check validity.
        /// </summary>
        /// <param name="buffer_out">User allocated buffer to store normalized name</param>
        /// <param name="buffer_size">Size of buffer_out</param>
        /// <param name="name">Reference name to be checked.</param>
        /// <param name="flags">Flags to constrain name validation rules - see the
        /// GIT_REFERENCE_FORMAT constants above.</param>
        /// <returns>0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
        /// or an error code.</returns>
        /// <remarks>
        /// This will normalize the reference name by removing any leading slash
        /// '/' characters and collapsing runs of adjacent slashes between name
        /// components into a single slash.Once normalized, if the reference name is valid, it will be returned in
        /// the user allocated buffer.See `git_reference_symbolic_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_reference_normalize_name(IntPtr buffer_out, size_t buffer_size, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, uint flags)
        {
            var __result__ = git_reference_normalize_name__(buffer_out, buffer_size, name, flags).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_normalize_name", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_normalize_name__(IntPtr buffer_out, size_t buffer_size, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, uint flags);
        
        /// <summary>
        /// Recursively peel reference until object of the specified type is found.
        /// </summary>
        /// <param name="out">Pointer to the peeled git_object</param>
        /// <param name="ref">The reference to be processed</param>
        /// <param name="type">The type of the requested object (GIT_OBJECT_COMMIT,
        /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).</param>
        /// <returns>0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code</returns>
        /// <remarks>
        /// The retrieved `peeled` object is owned by the repository
        /// and should be closed with the `git_object_free` method.If you pass `GIT_OBJECT_ANY` as the target type, then the object
        /// will be peeled until a non-tag object is met.
        /// </remarks>
        public static git_result git_reference_peel(out git_object @out, git_reference @ref, git_object_t type)
        {
            var __result__ = git_reference_peel__(out @out, @ref, type).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_reference_peel", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_reference_peel__(out git_object @out, git_reference @ref, git_object_t type);
        
        /// <summary>
        /// Ensure the reference name is well-formed.
        /// </summary>
        /// <param name="refname">name to be checked.</param>
        /// <returns>1 if the reference name is acceptable; 0 if it isn't</returns>
        /// <remarks>
        /// Valid reference names must follow one of two patterns:1. Top-level names must contain only capital letters and underscores,
        /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
        /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
        /// the characters '~', '^', ':', '
        /// \
        /// ', '?', '[', and '*', and the
        /// sequences ".." and "
        /// @
        /// {" which have special meaning to revparse.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_reference_is_valid_name([MarshalAs(UnmanagedType.LPUTF8Str)] string refname);
        
        /// <summary>
        /// Get the reference's short name
        /// </summary>
        /// <param name="ref">a reference</param>
        /// <returns>the human-readable version of the name</returns>
        /// <remarks>
        /// This will transform the reference name into a name "human-readable"
        /// version. If no shortname is appropriate, it will return the full
        /// name.The memory is owned by the reference and must not be freed.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_reference_shorthand(git_reference @ref);
    }
}
