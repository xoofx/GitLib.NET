//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Lookup a blob object from a repository.
        /// </summary>
        /// <param name="blob">pointer to the looked up blob</param>
        /// <param name="repo">the repo to use when locating the blob.</param>
        /// <param name="id">identity of the blob to locate.</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_blob_lookup(out git_blob blob, git_repository repo, in git_oid id)
        {
            var __result__ = git_blob_lookup__(out blob, repo, id).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_lookup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_lookup__(out git_blob blob, git_repository repo, in git_oid id);
        
        /// <summary>
        /// Lookup a blob object from a repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <seealso cref="git_object_lookup_prefix"/>
        /// 
        /// <param name="blob">pointer to the looked up blob</param>
        /// <param name="repo">the repo to use when locating the blob.</param>
        /// <param name="id">identity of the blob to locate.</param>
        /// <param name="len">the length of the short identifier</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_blob_lookup_prefix(out git_blob blob, git_repository repo, in git_oid id, size_t len)
        {
            var __result__ = git_blob_lookup_prefix__(out blob, repo, id, len).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_lookup_prefix", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_lookup_prefix__(out git_blob blob, git_repository repo, in git_oid id, size_t len);
        
        /// <summary>
        /// Close an open blob
        /// </summary>
        /// <param name="blob">the blob to close</param>
        /// <remarks>
        /// This is a wrapper around git_object_free()IMPORTANT:
        /// It *is* necessary to call this method when you stop
        /// using a blob. Failure to do so will cause a memory leak.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_blob_free(git_blob blob);
        
        /// <summary>
        /// Get the id of a blob.
        /// </summary>
        /// <param name="blob">a previously loaded blob.</param>
        /// <returns>SHA1 hash for this blob.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_blob_id(git_blob blob);
        
        /// <summary>
        /// Get the repository that contains the blob.
        /// </summary>
        /// <param name="blob">A previously loaded blob.</param>
        /// <returns>Repository that contains this blob.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_blob_owner(git_blob blob);
        
        /// <summary>
        /// Get a read-only buffer with the raw content of a blob.
        /// </summary>
        /// <param name="blob">pointer to the blob</param>
        /// <returns>the pointer</returns>
        /// <remarks>
        /// A pointer to the raw content of a blob is returned;
        /// this pointer is owned internally by the object and shall
        /// not be free'd. The pointer may be invalidated at a later
        /// time.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr git_blob_rawcontent(git_blob blob);
        
        /// <summary>
        /// Get the size in bytes of the contents of a blob
        /// </summary>
        /// <param name="blob">pointer to the blob</param>
        /// <returns>size on bytes</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_off_t git_blob_rawsize(git_blob blob);
        
        /// <summary>
        /// Get a buffer with the filtered content of a blob.
        /// </summary>
        /// <param name="out">The git_buf to be filled in</param>
        /// <param name="blob">Pointer to the blob</param>
        /// <param name="as_path">Path used for file attribute lookups, etc.</param>
        /// <param name="check_for_binary_data">Should this test if blob content contains
        /// NUL bytes / looks like binary data before applying filters?</param>
        /// <returns>0 on success or an error code</returns>
        /// <remarks>
        /// This applies filters as if the blob was being checked out to the
        /// working directory under the specified filename.  This may apply
        /// CRLF filtering or other types of changes depending on the file
        /// attributes set for the blob and the content detected in it.The output is written into a `git_buf` which the caller must free
        /// when done (via `git_buf_dispose`).If no filters need to be applied, then the `out` buffer will just
        /// be populated with a pointer to the raw content of the blob.  In
        /// that case, be careful to *not* free the blob until done with the
        /// buffer or copy it into memory you own.
        /// </remarks>
        public static git_result git_blob_filtered_content(out git_buf @out, git_blob blob, [MarshalAs(UnmanagedType.LPUTF8Str)] string as_path, int check_for_binary_data)
        {
            var __result__ = git_blob_filtered_content__(out @out, blob, as_path, check_for_binary_data).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_filtered_content", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_filtered_content__(out git_buf @out, git_blob blob, [MarshalAs(UnmanagedType.LPUTF8Str)] string as_path, int check_for_binary_data);
        
        /// <summary>
        /// Read a file from the working folder of a repository
        /// and write it to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository cannot be bare</param>
        /// <param name="relative_path">file from which the blob will be created,
        /// relative to the repository's working dir</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_blob_create_fromworkdir(ref git_oid id, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string relative_path)
        {
            var __result__ = git_blob_create_fromworkdir__(ref id, repo, relative_path).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_create_fromworkdir", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_create_fromworkdir__(ref git_oid id, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string relative_path);
        
        /// <summary>
        /// Read a file from the filesystem and write its content
        /// to the Object Database as a loose blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where the blob will be written.
        /// this repository can be bare or not</param>
        /// <param name="path">file from which the blob will be created</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_blob_create_fromdisk(ref git_oid id, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string path)
        {
            var __result__ = git_blob_create_fromdisk__(ref id, repo, path).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_create_fromdisk", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_create_fromdisk__(ref git_oid id, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);
        
        /// <summary>
        /// Create a stream to write a new blob into the object db
        /// </summary>
        /// <param name="out">the stream into which to write</param>
        /// <param name="repo">Repository where the blob will be written.
        /// This repository can be bare or not.</param>
        /// <param name="hintpath">If not NULL, will be used to select data filters
        /// to apply onto the content of the blob to be created.</param>
        /// <returns>0 or error code</returns>
        /// <remarks>
        /// This function may need to buffer the data on disk and will in
        /// general not be the right choice if you know the size of the data
        /// to write. If you have data in memory, use
        /// `git_blob_create_frombuffer()`. If you do not, but know the size of
        /// the contents (and don't want/need to perform filtering), use
        /// `git_odb_open_wstream()`.Don't close this stream yourself but pass it to
        /// `git_blob_create_fromstream_commit()` to commit the write to the
        /// object db and get the object id.If the `hintpath` parameter is filled, it will be used to determine
        /// what git filters should be applied to the object before it is written
        /// to the object database.
        /// </remarks>
        public static git_result git_blob_create_fromstream(out IntPtr @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string hintpath)
        {
            var __result__ = git_blob_create_fromstream__(out @out, repo, hintpath).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_create_fromstream", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_create_fromstream__(out IntPtr @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string hintpath);
        
        /// <summary>
        /// Close the stream and write the blob to the object db
        /// </summary>
        /// <param name="out">the id of the new blob</param>
        /// <param name="stream">the stream to close</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The stream will be closed and freed.
        /// </remarks>
        public static git_result git_blob_create_fromstream_commit(out git_oid @out, ref git_writestream stream)
        {
            var __result__ = git_blob_create_fromstream_commit__(out @out, ref stream).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_create_fromstream_commit", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_create_fromstream_commit__(out git_oid @out, ref git_writestream stream);
        
        /// <summary>
        /// Write an in-memory buffer to the ODB as a blob
        /// </summary>
        /// <param name="id">return the id of the written blob</param>
        /// <param name="repo">repository where to blob will be written</param>
        /// <param name="buffer">data to be written into the blob</param>
        /// <param name="len">length of the data</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_blob_create_frombuffer(ref git_oid id, git_repository repo, IntPtr buffer, size_t len)
        {
            var __result__ = git_blob_create_frombuffer__(ref id, repo, buffer, len).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_blob_create_frombuffer", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_blob_create_frombuffer__(ref git_oid id, git_repository repo, IntPtr buffer, size_t len);
        
        /// <summary>
        /// Determine if the blob content is most certainly binary or not.
        /// </summary>
        /// <param name="blob">The blob which content should be analyzed</param>
        /// <returns>1 if the content of the blob is detected
        /// as binary; 0 otherwise.</returns>
        /// <remarks>
        /// The heuristic used to guess if a file is binary is taken from core git:
        /// Searching for NUL bytes and looking for a reasonable ratio of printable
        /// to non-printable characters among the first 8000 bytes.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_blob_is_binary(git_blob blob);
        
        /// <summary>
        /// Create an in-memory copy of a blob. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="out">Pointer to store the copy of the object</param>
        /// <param name="source">Original object to copy</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_blob_dup(out git_blob @out, git_blob source);
    }
}
