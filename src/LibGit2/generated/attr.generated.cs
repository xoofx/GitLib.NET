//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Possible states for an attribute
        /// </summary>
        public enum git_attr_t : int
        {
            /// <summary>
            /// The attribute has been left unspecified
            /// </summary>
            GIT_ATTR_UNSPECIFIED_T = (int)0,
            
            /// <summary>
            /// The attribute has been set
            /// </summary>
            GIT_ATTR_TRUE_T,
            
            /// <summary>
            /// The attribute has been unset
            /// </summary>
            GIT_ATTR_FALSE_T,
            
            /// <summary>
            /// This attribute has a value
            /// </summary>
            GIT_ATTR_VALUE_T,
        }
        
        /// <summary>
        /// The attribute has been left unspecified
        /// </summary>
        public const git_attr_t GIT_ATTR_UNSPECIFIED_T = git_attr_t.GIT_ATTR_UNSPECIFIED_T;
        
        /// <summary>
        /// The attribute has been set
        /// </summary>
        public const git_attr_t GIT_ATTR_TRUE_T = git_attr_t.GIT_ATTR_TRUE_T;
        
        /// <summary>
        /// The attribute has been unset
        /// </summary>
        public const git_attr_t GIT_ATTR_FALSE_T = git_attr_t.GIT_ATTR_FALSE_T;
        
        /// <summary>
        /// This attribute has a value
        /// </summary>
        public const git_attr_t GIT_ATTR_VALUE_T = git_attr_t.GIT_ATTR_VALUE_T;
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_attr_foreach_cb([MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string value, IntPtr payload);
        
        /// <summary>
        /// Return the value type for a given attribute.
        /// </summary>
        /// <param name="attr">The attribute</param>
        /// <returns>the value type for the attribute</returns>
        /// <remarks>
        /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
        /// was not set at all), or `VALUE`, if the attribute was set to an
        /// actual string.If the attribute has a `VALUE` string, it can be accessed normally
        /// as a NULL-terminated C string.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_attr_t git_attr_value([MarshalAs(UnmanagedType.LPUTF8Str)] string attr);
        
        /// <summary>
        /// Look up the value of one git attribute for path.
        /// </summary>
        /// <param name="value_out">Output of the value of the attribute.  Use the GIT_ATTR_...
        /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
        /// use the string value for attributes set to a value.  You
        /// should NOT modify or free this value.</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path to check for attributes.  Relative paths are
        /// interpreted relative to the repo root.  The file does
        /// not have to exist, but if it does not, then it will be
        /// treated as a plain file (not a directory).</param>
        /// <param name="name">The name of the attribute to look up.</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_attr_get(out string value_out, git_repository repo, uint flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Look up a list of git attributes for path.
        /// </summary>
        /// <param name="values_out">An array of num_attr entries that will have string
        /// pointers written into it for the values of the attributes.
        /// You should not modify or free the values that are written
        /// into this array (although of course, you should free the
        /// array itself if you allocated it).</param>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">The path inside the repo to check attributes.  This
        /// does not have to exist, but if it does not, then
        /// it will be treated as a plain file (i.e. not a directory).</param>
        /// <param name="num_attr">The number of attributes being looked up</param>
        /// <param name="names">An array of num_attr strings containing attribute names.</param>
        /// <remarks>
        /// Use this if you have a known list of attributes that you want to
        /// look up in a single call.  This is somewhat more efficient than
        /// calling `git_attr_get()` multiple times.For example, you might write:const char *attrs[] = { "crlf", "diff", "foo" };
        /// const char **values[3];
        /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);Then you could loop through the 3 values to get the settings for
        /// the three attributes you asked about.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_attr_get_many(out string values_out, git_repository repo, uint flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, size_t num_attr, out string names);
        
        /// <summary>
        /// Loop over all the git attributes for a path.
        /// </summary>
        /// <param name="repo">The repository containing the path.</param>
        /// <param name="flags">A combination of GIT_ATTR_CHECK... flags.</param>
        /// <param name="path">Path inside the repo to check attributes.  This does not have
        /// to exist, but if it does not, then it will be treated as a
        /// plain file (i.e. not a directory).</param>
        /// <param name="callback">Function to invoke on each attribute name and value.
        /// See git_attr_foreach_cb.</param>
        /// <param name="payload">Passed on as extra parameter to callback function.</param>
        /// <returns>0 on success, non-zero callback return value, or error code</returns>
        public static git_result git_attr_foreach(git_repository repo, uint flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, git_attr_foreach_cb callback, IntPtr payload)
        {
            var __result__ = git_attr_foreach__(repo, flags, path, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_attr_foreach", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_attr_foreach__(git_repository repo, uint flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, git_attr_foreach_cb callback, IntPtr payload);
        
        /// <summary>
        /// Flush the gitattributes cache.
        /// </summary>
        /// <remarks>
        /// Call this if you have reason to believe that the attributes files on
        /// disk no longer match the cached contents of memory.  This will cause
        /// the attributes files to be reloaded the next time that an attribute
        /// access function is called.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_attr_cache_flush(git_repository repo);
        
        /// <summary>
        /// Add a macro definition.
        /// </summary>
        /// <remarks>
        /// Macros will automatically be loaded from the top level `.gitattributes`
        /// file of the repository (plus the build-in "binary" macro).  This
        /// function allows you to add others.  For example, to add the default
        /// macro, you would call:git_attr_add_macro(repo, "binary", "-diff -crlf");
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_attr_add_macro(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string values);
    }
}
