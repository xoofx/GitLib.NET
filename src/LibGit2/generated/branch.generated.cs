//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Iterator type for branches
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct git_branch_iterator : IEquatable<git_branch_iterator>
        {
            private readonly IntPtr _handle;
            
            public git_branch_iterator(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(git_branch_iterator other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is git_branch_iterator other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(git_branch_iterator left, git_branch_iterator right) => left.Equals(right);
            
            public static bool operator !=(git_branch_iterator left, git_branch_iterator right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <param name="out">Pointer where to store the underlying reference.</param>
        /// <param name="branch_name">Name for the branch; this name is
        /// validated for consistency. It should also not conflict with
        /// an already existing branch name.</param>
        /// <param name="target">Commit to which this branch should point. This object
        /// must belong to the given `repo`.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>0, GIT_EINVALIDSPEC or an error code.
        /// A proper reference is written in the refs/heads namespace
        /// pointing to the provided target commit.</returns>
        /// <remarks>
        /// A new direct reference will be created pointing to
        /// this target commit. If `force` is true and a reference
        /// already exists with the given name, it'll be replaced.The returned reference must be freed by the user.The branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_branch_create(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string branch_name, git_commit target, int force)
        {
            var __result__ = git_branch_create__(out @out, repo, branch_name, target, force).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_create", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_create__(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string branch_name, git_commit target, int force);
        
        /// <summary>
        /// Create a new branch pointing at a target commit
        /// </summary>
        /// <seealso cref="git_branch_create"/>
        /// 
        /// <remarks>
        /// This behaves like `git_branch_create()` but takes an annotated
        /// commit, which lets you specify which extended sha syntax string was
        /// specified by a user, allowing for more exact reflog messages.See the documentation for `git_branch_create()`.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_create_from_annotated(out git_reference ref_out, git_repository repository, [MarshalAs(UnmanagedType.LPUTF8Str)] string branch_name, git_annotated_commit commit, int force);
        
        /// <summary>
        /// Delete an existing branch reference.
        /// </summary>
        /// <param name="branch">A valid reference representing a branch</param>
        /// <returns>0 on success, or an error code.</returns>
        /// <remarks>
        /// If the branch is successfully deleted, the passed reference
        /// object will be invalidated. The reference must be freed manually
        /// by the user.
        /// </remarks>
        public static git_result git_branch_delete(git_reference branch)
        {
            var __result__ = git_branch_delete__(branch).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_delete", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_delete__(git_reference branch);
        
        /// <summary>
        /// Create an iterator which loops over the requested branches.
        /// </summary>
        /// <param name="out">the iterator</param>
        /// <param name="repo">Repository where to find the branches.</param>
        /// <param name="list_flags">Filtering flags for the branch
        /// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
        /// or GIT_BRANCH_ALL.</param>
        /// <returns>0 on success  or an error code</returns>
        public static git_result git_branch_iterator_new(out git_branch_iterator @out, git_repository repo, git_branch_t list_flags)
        {
            var __result__ = git_branch_iterator_new__(out @out, repo, list_flags).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_iterator_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_iterator_new__(out git_branch_iterator @out, git_repository repo, git_branch_t list_flags);
        
        /// <summary>
        /// Retrieve the next branch from the iterator
        /// </summary>
        /// <param name="out">the reference</param>
        /// <param name="out_type">the type of branch (local or remote-tracking)</param>
        /// <param name="iter">the branch iterator</param>
        /// <returns>0 on success, GIT_ITEROVER if there are no more branches or an error code.</returns>
        public static git_result git_branch_next(out git_reference @out, ref git_branch_t out_type, git_branch_iterator iter)
        {
            var __result__ = git_branch_next__(out @out, ref out_type, iter).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_next", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_next__(out git_reference @out, ref git_branch_t out_type, git_branch_iterator iter);
        
        /// <summary>
        /// Free a branch iterator
        /// </summary>
        /// <param name="iter">the iterator to free</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_branch_iterator_free(git_branch_iterator iter);
        
        /// <summary>
        /// Move/rename an existing local branch reference.
        /// </summary>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <param name="new_branch_name">Target name of the branch once the move
        /// is performed; this name is validated for consistency.</param>
        /// <param name="force">Overwrite existing branch.</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC or an error code.</returns>
        /// <remarks>
        /// The new branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_branch_move(out git_reference @out, git_reference branch, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_branch_name, int force)
        {
            var __result__ = git_branch_move__(out @out, branch, new_branch_name, force).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_move", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_move__(out git_reference @out, git_reference branch, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_branch_name, int force);
        
        /// <summary>
        /// Lookup a branch by its name in a repository.
        /// </summary>
        /// <param name="out">pointer to the looked-up branch reference</param>
        /// <param name="repo">the repository to look up the branch</param>
        /// <param name="branch_name">Name of the branch to be looked-up;
        /// this name is validated for consistency.</param>
        /// <param name="branch_type">Type of the considered branch. This should
        /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.</param>
        /// <returns>0 on success; GIT_ENOTFOUND when no matching branch
        /// exists, GIT_EINVALIDSPEC, otherwise an error code.</returns>
        /// <remarks>
        /// The generated reference must be freed by the user.The branch name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_lookup(out git_reference @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string branch_name, git_branch_t branch_type);
        
        /// <summary>
        /// Return the name of the given local or remote branch.
        /// </summary>
        /// <param name="out">where the pointer of branch name is stored;
        /// this is valid as long as the ref is not freed.</param>
        /// <param name="ref">the reference ideally pointing to a branch</param>
        /// <returns>0 on success; otherwise an error code (e.g., if the
        /// ref is no local or remote branch).</returns>
        /// <remarks>
        /// The name of the branch matches the definition of the name
        /// for git_branch_lookup. That is, if the returned name is given
        /// to git_branch_lookup() then the reference is returned that
        /// was given to this function.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_name(out string @out, git_reference @ref);
        
        /// <summary>
        /// Return the reference supporting the remote tracking branch,
        /// given a local branch reference.
        /// </summary>
        /// <param name="out">Pointer where to store the retrieved
        /// reference.</param>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <returns>0 on success; GIT_ENOTFOUND when no remote tracking
        /// reference exists, otherwise an error code.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_upstream(out git_reference @out, git_reference branch);
        
        /// <summary>
        /// Set the upstream configuration for a given local branch
        /// </summary>
        /// <param name="branch">the branch to configure</param>
        /// <param name="upstream_name">remote-tracking or local branch to set as
        /// upstream. Pass NULL to unset.</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_branch_set_upstream(git_reference branch, [MarshalAs(UnmanagedType.LPUTF8Str)] string upstream_name)
        {
            var __result__ = git_branch_set_upstream__(branch, upstream_name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_set_upstream", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_set_upstream__(git_reference branch, [MarshalAs(UnmanagedType.LPUTF8Str)] string upstream_name);
        
        /// <summary>
        /// Return the name of the reference supporting the remote tracking branch,
        /// given the name of a local branch reference.
        /// </summary>
        /// <param name="out">Pointer to the user-allocated git_buf which will be
        /// filled with the name of the reference.</param>
        /// <param name="repo">the repository where the branches live</param>
        /// <param name="refname">reference name of the local branch.</param>
        /// <returns>0, GIT_ENOTFOUND when no remote tracking reference exists,
        /// otherwise an error code.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_upstream_name(out git_buf @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname);
        
        /// <summary>
        /// Determine if the current local branch is pointed at by HEAD.
        /// </summary>
        /// <param name="branch">Current underlying reference of the branch.</param>
        /// <returns>1 if HEAD points at the branch, 0 if it isn't,
        /// error code otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_is_head(git_reference branch);
        
        /// <summary>
        /// Determine if the current branch is checked out in any linked
        /// repository.
        /// </summary>
        /// <param name="branch">Reference to the branch.</param>
        /// <returns>1 if branch is checked out, 0 if it isn't,
        /// error code otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_is_checked_out(git_reference branch);
        
        /// <summary>
        /// Return the name of remote that the remote tracking branch belongs to.
        /// </summary>
        /// <param name="out">Pointer to the user-allocated git_buf which will be filled with the name of the remote.</param>
        /// <param name="repo">The repository where the branch lives.</param>
        /// <param name="canonical_branch_name">name of the remote tracking branch.</param>
        /// <returns>0, GIT_ENOTFOUND
        /// when no remote matching remote was found,
        /// GIT_EAMBIGUOUS when the branch maps to several remotes,
        /// otherwise an error code.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_branch_remote_name(out git_buf @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string canonical_branch_name);
        
        /// <summary>
        /// Retrieve the name of the upstream remote of a local branch
        /// </summary>
        /// <param name="buf">the buffer into which to write the name</param>
        /// <param name="repo">the repository in which to look</param>
        /// <param name="refname">the full name of the branch</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_branch_upstream_remote(ref git_buf buf, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname)
        {
            var __result__ = git_branch_upstream_remote__(ref buf, repo, refname).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_branch_upstream_remote", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_branch_upstream_remote__(ref git_buf buf, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string refname);
    }
}
