//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Argument to the completion callback which tells it which operation
        /// finished.
        /// </summary>
        public enum git_remote_completion_type : int
        {
            GIT_REMOTE_COMPLETION_DOWNLOAD,
            
            GIT_REMOTE_COMPLETION_INDEXING,
            
            GIT_REMOTE_COMPLETION_ERROR,
        }
        
        public const git_remote_completion_type GIT_REMOTE_COMPLETION_DOWNLOAD = git_remote_completion_type.GIT_REMOTE_COMPLETION_DOWNLOAD;
        
        public const git_remote_completion_type GIT_REMOTE_COMPLETION_INDEXING = git_remote_completion_type.GIT_REMOTE_COMPLETION_INDEXING;
        
        public const git_remote_completion_type GIT_REMOTE_COMPLETION_ERROR = git_remote_completion_type.GIT_REMOTE_COMPLETION_ERROR;
        
        /// <summary>
        /// Remote creation options flags
        /// </summary>
        [Flags]
        public enum git_remote_create_flags : int
        {
            /// <summary>
            /// Ignore the repository apply.insteadOf configuration
            /// </summary>
            GIT_REMOTE_CREATE_SKIP_INSTEADOF = (int)(1 << 0),
            
            /// <summary>
            /// Don't build a fetchspec from the name if none is set
            /// </summary>
            GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = (int)(1 << 1),
        }
        
        /// <summary>
        /// Ignore the repository apply.insteadOf configuration
        /// </summary>
        public const git_remote_create_flags GIT_REMOTE_CREATE_SKIP_INSTEADOF = git_remote_create_flags.GIT_REMOTE_CREATE_SKIP_INSTEADOF;
        
        /// <summary>
        /// Don't build a fetchspec from the name if none is set
        /// </summary>
        public const git_remote_create_flags GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = git_remote_create_flags.GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC;
        
        public enum git_fetch_prune_t : int
        {
            /// <summary>
            /// Use the setting from the configuration
            /// </summary>
            GIT_FETCH_PRUNE_UNSPECIFIED,
            
            /// <summary>
            /// Force pruning on
            /// </summary>
            GIT_FETCH_PRUNE,
            
            /// <summary>
            /// Force pruning off
            /// </summary>
            GIT_FETCH_NO_PRUNE,
        }
        
        /// <summary>
        /// Use the setting from the configuration
        /// </summary>
        public const git_fetch_prune_t GIT_FETCH_PRUNE_UNSPECIFIED = git_fetch_prune_t.GIT_FETCH_PRUNE_UNSPECIFIED;
        
        /// <summary>
        /// Force pruning on
        /// </summary>
        public const git_fetch_prune_t GIT_FETCH_PRUNE = git_fetch_prune_t.GIT_FETCH_PRUNE;
        
        /// <summary>
        /// Force pruning off
        /// </summary>
        public const git_fetch_prune_t GIT_FETCH_NO_PRUNE = git_fetch_prune_t.GIT_FETCH_NO_PRUNE;
        
        /// <summary>
        /// Automatic tag following option
        /// </summary>
        /// <remarks>
        /// Lets us select the --tags option to use.
        /// </remarks>
        public enum git_remote_autotag_option_t : int
        {
            /// <summary>
            /// Use the setting from the configuration.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = (int)0,
            
            /// <summary>
            /// Ask the server for tags pointing to objects we're already
            /// downloading.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
            
            /// <summary>
            /// Don't ask for any tags beyond the refspecs.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_NONE,
            
            /// <summary>
            /// Ask for the all the tags.
            /// </summary>
            GIT_REMOTE_DOWNLOAD_TAGS_ALL,
        }
        
        /// <summary>
        /// Use the setting from the configuration.
        /// </summary>
        public const git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED;
        
        /// <summary>
        /// Ask the server for tags pointing to objects we're already
        /// downloading.
        /// </summary>
        public const git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_AUTO = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_AUTO;
        
        /// <summary>
        /// Don't ask for any tags beyond the refspecs.
        /// </summary>
        public const git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_NONE = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_NONE;
        
        /// <summary>
        /// Ask for the all the tags.
        /// </summary>
        public const git_remote_autotag_option_t GIT_REMOTE_DOWNLOAD_TAGS_ALL = git_remote_autotag_option_t.GIT_REMOTE_DOWNLOAD_TAGS_ALL;
        
        /// <summary>
        /// The callback settings structure
        /// </summary>
        /// <remarks>
        /// Set the callbacks to be called by the remote when informing the user
        /// about the progress of the network operations.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_remote_callbacks
        {
            public uint version;
            
            /// <summary>
            /// Textual progress from the remote. Text send over the
            /// progress side-band will be passed to this function (this is
            /// the 'counting objects' output).
            /// </summary>
            public git_transport_message_cb sideband_progress;
            
            public completion_delegate completion;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate int completion_delegate(git_remote_completion_type type, IntPtr data);
            
            /// <summary>
            /// This will be called if the remote host requires
            /// authentication in order to connect to it.
            /// </summary>
            /// <remarks>
            /// Returning GIT_PASSTHROUGH will make libgit2 behave as
            /// though this field isn't set.
            /// </remarks>
            public git_cred_acquire_cb credentials;
            
            /// <summary>
            /// If cert verification fails, this will be called to let the
            /// user make the final decision of whether to allow the
            /// connection to proceed. Returns 0 to allow the connection
            /// or a negative value to indicate an error.
            /// </summary>
            public git_transport_certificate_check_cb certificate_check;
            
            /// <summary>
            /// During the download of new data, this will be regularly
            /// called with the current count of progress done by the
            /// indexer.
            /// </summary>
            public git_transfer_progress_cb transfer_progress;
            
            public update_tips_delegate update_tips;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate int update_tips_delegate(git_remote_completion_type type, IntPtr data);
            
            /// <summary>
            /// Function to call with progress information during pack
            /// building. Be aware that this is called inline with pack
            /// building operations, so performance may be affected.
            /// </summary>
            public git_packbuilder_progress pack_progress;
            
            /// <summary>
            /// Function to call with progress information during the
            /// upload portion of a push. Be aware that this is called
            /// inline with pack building operations, so performance may be
            /// affected.
            /// </summary>
            public git_push_transfer_progress push_transfer_progress;
            
            /// <summary>
            /// See documentation of git_push_update_reference_cb
            /// </summary>
            public git_push_update_reference_cb push_update_reference;
            
            /// <summary>
            /// Called once between the negotiation step and the upload. It
            /// provides information about what updates will be performed.
            /// </summary>
            public git_push_negotiation push_negotiation;
            
            /// <summary>
            /// Create the transport to use for this operation. Leave NULL
            /// to auto-detect.
            /// </summary>
            public git_transport_cb transport;
            
            /// <summary>
            /// This will be passed to each of the callbacks in this struct
            /// as the last parameter.
            /// </summary>
            public IntPtr payload;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_push_transfer_progress(uint current, uint total, size_t bytes, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_push_update_reference_cb([MarshalAs(UnmanagedType.LPUTF8Str)] string refname, [MarshalAs(UnmanagedType.LPUTF8Str)] string status, IntPtr data);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_push_negotiation(out IntPtr updates, size_t len, IntPtr payload);
        
        /// <summary>
        /// Represents an update which will be performed on the remote during push
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_push_update
        {
            /// <summary>
            /// The source name of the reference
            /// </summary>
            public IntPtr src_refname;
            
            /// <summary>
            /// The name of the reference to update on the server
            /// </summary>
            public IntPtr dst_refname;
            
            /// <summary>
            /// The current target of the reference
            /// </summary>
            public git_oid src;
            
            /// <summary>
            /// The new target for the reference
            /// </summary>
            public git_oid dst;
        }
        
        /// <summary>
        /// Remote creation options structure
        /// </summary>
        /// <remarks>
        /// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
        /// use `git_remote_create_init_options`.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_remote_create_options
        {
            public uint version;
            
            /// <summary>
            /// The repository that should own the remote.
            /// Setting this to NULL results in a detached remote.
            /// </summary>
            public git_repository repository;
            
            /// <summary>
            /// The remote's name.
            /// Setting this to NULL results in an in-memory/anonymous remote.
            /// </summary>
            [MarshalAs(UnmanagedType.LPUTF8Str)]
            public string name;
            
            /// <summary>
            /// The fetchspec the remote should use.
            /// </summary>
            [MarshalAs(UnmanagedType.LPUTF8Str)]
            public string fetchspec;
            
            /// <summary>
            /// Additional flags for the remote. See git_remote_create_flags.
            /// </summary>
            public uint flags;
        }
        
        /// <summary>
        /// Fetch options structure.
        /// </summary>
        /// <remarks>
        /// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
        /// correctly set the `version` field.  E.g.git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_fetch_options
        {
            public int version;
            
            /// <summary>
            /// Callbacks to use for this fetch operation
            /// </summary>
            public git_remote_callbacks callbacks;
            
            /// <summary>
            /// Whether to perform a prune after the fetch
            /// </summary>
            public git_fetch_prune_t prune;
            
            /// <summary>
            /// Whether to write the results to FETCH_HEAD. Defaults to
            /// on. Leave this default in order to behave like git.
            /// </summary>
            public int update_fetchhead;
            
            /// <summary>
            /// Determines how to behave regarding tags on the remote, such
            /// as auto-downloading tags for objects we're downloading or
            /// downloading all of them.
            /// </summary>
            /// <remarks>
            /// The default is to auto-follow tags.
            /// </remarks>
            public git_remote_autotag_option_t download_tags;
            
            /// <summary>
            /// Proxy options to use, by default no proxy is used.
            /// </summary>
            public git_proxy_options proxy_opts;
            
            /// <summary>
            /// Extra headers for this fetch operation
            /// </summary>
            public git_strarray custom_headers;
        }
        
        /// <summary>
        /// Controls the behavior of a git_push object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_push_options
        {
            public uint version;
            
            /// <summary>
            /// If the transport being used to push to the remote requires the creation
            /// of a pack file, this controls the number of worker threads used by
            /// the packbuilder when creating that pack file to be sent to the remote.
            /// </summary>
            /// <remarks>
            /// If set to 0, the packbuilder will auto-detect the number of threads
            /// to create. The default value is 1.
            /// </remarks>
            public uint pb_parallelism;
            
            /// <summary>
            /// Callbacks to use for this push operation
            /// </summary>
            public git_remote_callbacks callbacks;
            
            /// <summary>
            /// Proxy options to use, by default no proxy is used.
            /// </summary>
            public git_proxy_options proxy_opts;
            
            /// <summary>
            /// Extra headers for this push operation
            /// </summary>
            public git_strarray custom_headers;
        }
        
        /// <summary>
        /// Add a remote with the default fetch refspec to the repository's configuration.
        /// </summary>
        /// <param name="@out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <returns>0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        public static git_result git_remote_create(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string url)
        {
            var __result__ = git_remote_create__(out @out, repo, name, url).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create__(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string url);
        
        /// <summary>
        /// Initialize git_remote_create_options structure
        /// </summary>
        /// <param name="opts">The `git_remote_create_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_remote_create_options` with default values. Equivalent to
        /// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_remote_create_init_options(ref git_remote_create_options opts, uint version)
        {
            var __result__ = git_remote_create_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create_init_options__(ref git_remote_create_options opts, uint version);
        
        /// <summary>
        /// Create a remote, with options.
        /// </summary>
        /// <param name="@out">the resulting remote</param>
        /// <param name="url">the remote's url</param>
        /// <param name="opts">the remote creation options</param>
        /// <returns>0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// This function allows more fine-grained control over the remote creation.Passing NULL as the opts argument will result in a detached remote.
        /// </remarks>
        public static git_result git_remote_create_with_opts(out git_remote @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string url, in git_remote_create_options opts)
        {
            var __result__ = git_remote_create_with_opts__(out @out, url, opts).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create_with_opts", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create_with_opts__(out git_remote @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string url, in git_remote_create_options opts);
        
        /// <summary>
        /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
        /// configuration.
        /// </summary>
        /// <param name="@out">the resulting remote</param>
        /// <param name="repo">the repository in which to create the remote</param>
        /// <param name="name">the remote's name</param>
        /// <param name="url">the remote's url</param>
        /// <param name="fetch">the remote fetch value</param>
        /// <returns>0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        public static git_result git_remote_create_with_fetchspec(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string url, [MarshalAs(UnmanagedType.LPUTF8Str)] string fetch)
        {
            var __result__ = git_remote_create_with_fetchspec__(out @out, repo, name, url, fetch).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create_with_fetchspec", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create_with_fetchspec__(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string url, [MarshalAs(UnmanagedType.LPUTF8Str)] string fetch);
        
        /// <summary>
        /// Create an anonymous remote
        /// </summary>
        /// <param name="@out">pointer to the new remote objects</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.
        /// </remarks>
        public static git_result git_remote_create_anonymous(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string url)
        {
            var __result__ = git_remote_create_anonymous__(out @out, repo, url).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create_anonymous", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create_anonymous__(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string url);
        
        /// <summary>
        /// Create a remote without a connected local repo
        /// </summary>
        /// <param name="@out">pointer to the new remote objects</param>
        /// <param name="url">the remote repository's URL</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Create a remote with the given url in-memory. You can use this when
        /// you have a URL instead of a remote's name.Contrasted with git_remote_create_anonymous, a detached remote
        /// will not consider any repo configuration values (such as insteadof url
        /// substitutions).
        /// </remarks>
        public static git_result git_remote_create_detached(out git_remote @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string url)
        {
            var __result__ = git_remote_create_detached__(out @out, url).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_create_detached", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_create_detached__(out git_remote @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string url);
        
        /// <summary>
        /// Get the information for a particular remote
        /// </summary>
        /// <param name="@out">pointer to the new remote object</param>
        /// <param name="repo">the associated repository</param>
        /// <param name="name">the remote's name</param>
        /// <returns>0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code</returns>
        /// <remarks>
        /// The name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.
        /// </remarks>
        public static git_result git_remote_lookup(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name)
        {
            var __result__ = git_remote_lookup__(out @out, repo, name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_lookup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_lookup__(out git_remote @out, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Create a copy of an existing remote.  All internal strings are also
        /// duplicated. Callbacks are not duplicated.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="source">object to copy</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Call `git_remote_free` to free the data.
        /// </remarks>
        public static git_result git_remote_dup(out git_remote dest, git_remote source)
        {
            var __result__ = git_remote_dup__(out dest, source).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_dup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_dup__(out git_remote dest, git_remote source);
        
        /// <summary>
        /// Get the remote's repository
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>a pointer to the repository</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_remote_owner(git_remote remote);
        
        /// <summary>
        /// Get the remote's name
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>a pointer to the name or NULL for in-memory remotes</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_remote_name(git_remote remote);
        
        /// <summary>
        /// Get the remote's url
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>a pointer to the url</returns>
        /// <remarks>
        /// If url.*.insteadOf has been configured for this URL, it will
        /// return the modified URL.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_remote_url(git_remote remote);
        
        /// <summary>
        /// Get the remote's url for pushing
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>a pointer to the url or NULL if no special url for pushing is set</returns>
        /// <remarks>
        /// If url.*.pushInsteadOf has been configured for this URL, it
        /// will return the modified URL.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_remote_pushurl(git_remote remote);
        
        /// <summary>
        /// Set the remote's url in the configuration
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <returns>0 or an error value</returns>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        public static git_result git_remote_set_url(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string url)
        {
            var __result__ = git_remote_set_url__(repo, remote, url).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_set_url", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_set_url__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string url);
        
        /// <summary>
        /// Set the remote's url for pushing in the configuration.
        /// </summary>
        /// <param name="repo">the repository in which to perform the change</param>
        /// <param name="remote">the remote's name</param>
        /// <param name="url">the url to set</param>
        /// <remarks>
        /// Remote objects already in memory will not be affected. This assumes
        /// the common case of a single-url remote and will otherwise return an error.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_remote_set_pushurl(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string url);
        
        /// <summary>
        /// Add a fetch refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new fetch refspec</param>
        /// <returns>0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the fetch list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        public static git_result git_remote_add_fetch(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string refspec)
        {
            var __result__ = git_remote_add_fetch__(repo, remote, refspec).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_add_fetch", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_add_fetch__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string refspec);
        
        /// <summary>
        /// Get the remote's list of fetch refspecs
        /// </summary>
        /// <param name="array">pointer to the array in which to store the strings</param>
        /// <param name="remote">the remote to query</param>
        /// <remarks>
        /// The memory is owned by the user and should be freed with
        /// `git_strarray_free`.
        /// </remarks>
        public static int git_remote_get_fetch_refspecs(out string[] array, git_remote remote)
        {
            git_strarray array__;
            var __result__ = git_remote_get_fetch_refspecs__(out array__, remote);
            array = array__.ToArray();
            git_strarray_free(ref array__);
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_get_fetch_refspecs", CallingConvention = CallingConvention.Cdecl)]
        private static extern int git_remote_get_fetch_refspecs__(out git_strarray array, git_remote remote);
        
        /// <summary>
        /// Add a push refspec to the remote's configuration
        /// </summary>
        /// <param name="repo">the repository in which to change the configuration</param>
        /// <param name="remote">the name of the remote to change</param>
        /// <param name="refspec">the new push refspec</param>
        /// <returns>0, GIT_EINVALIDSPEC if refspec is invalid or an error value</returns>
        /// <remarks>
        /// Add the given refspec to the push list in the configuration. No
        /// loaded remote instances will be affected.
        /// </remarks>
        public static git_result git_remote_add_push(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string refspec)
        {
            var __result__ = git_remote_add_push__(repo, remote, refspec).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_add_push", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_add_push__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, [MarshalAs(UnmanagedType.LPUTF8Str)] string refspec);
        
        /// <summary>
        /// Get the remote's list of push refspecs
        /// </summary>
        /// <param name="array">pointer to the array in which to store the strings</param>
        /// <param name="remote">the remote to query</param>
        /// <remarks>
        /// The memory is owned by the user and should be freed with
        /// `git_strarray_free`.
        /// </remarks>
        public static int git_remote_get_push_refspecs(out string[] array, git_remote remote)
        {
            git_strarray array__;
            var __result__ = git_remote_get_push_refspecs__(out array__, remote);
            array = array__.ToArray();
            git_strarray_free(ref array__);
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_get_push_refspecs", CallingConvention = CallingConvention.Cdecl)]
        private static extern int git_remote_get_push_refspecs__(out git_strarray array, git_remote remote);
        
        /// <summary>
        /// Get the number of refspecs for a remote
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>the amount of refspecs configured in this remote</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern size_t git_remote_refspec_count(git_remote remote);
        
        /// <summary>
        /// Get a refspec from the remote
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <param name="n">the refspec to get</param>
        /// <returns>the nth refspec</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_refspec git_remote_get_refspec(git_remote remote, size_t n);
        
        /// <summary>
        /// Open a connection to a remote
        /// </summary>
        /// <param name="remote">the remote to connect to</param>
        /// <param name="direction">GIT_DIRECTION_FETCH if you want to fetch or
        /// GIT_DIRECTION_PUSH if you want to push</param>
        /// <param name="callbacks">the callbacks to use for this connection</param>
        /// <param name="proxy_opts">proxy settings</param>
        /// <param name="custom_headers">extra HTTP headers to use in this connection</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The transport is selected based on the URL. The direction argument
        /// is due to a limitation of the git protocol (over TCP or SSH) which
        /// starts up a specific binary which can only do the one or the other.
        /// </remarks>
        public static git_result git_remote_connect(git_remote remote, git_direction direction, in git_remote_callbacks callbacks, in git_proxy_options proxy_opts, string[] custom_headers)
        {
            var custom_headers__ = git_strarray.Allocate(custom_headers);
            var __result__ = git_remote_connect__(remote, direction, callbacks, proxy_opts, in custom_headers__);
            custom_headers__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_connect", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_connect__(git_remote remote, git_direction direction, in git_remote_callbacks callbacks, in git_proxy_options proxy_opts, in git_strarray custom_headers);
        
        /// <summary>
        /// Get the remote repository's reference advertisement list
        /// </summary>
        /// <param name="@out">pointer to the array</param>
        /// <param name="size">the number of remote heads</param>
        /// <param name="remote">the remote</param>
        /// <returns>0 on success, or an error code</returns>
        /// <remarks>
        /// Get the list of references with which the server responds to a new
        /// connection.The remote (or more exactly its transport) must have connected to
        /// the remote repository. This list is available as soon as the
        /// connection to the remote is initiated and it remains available
        /// after disconnecting.The memory belongs to the remote. The pointer will be valid as long
        /// as a new connection is not initiated, but it is recommended that
        /// you make a copy in order to make use of the data.
        /// </remarks>
        public static git_result git_remote_ls(out IntPtr @out, ref size_t size, git_remote remote)
        {
            var __result__ = git_remote_ls__(out @out, ref size, remote).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_ls", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_ls__(out IntPtr @out, ref size_t size, git_remote remote);
        
        /// <summary>
        /// Check whether the remote is connected
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <returns>1 if it's connected, 0 otherwise.</returns>
        /// <remarks>
        /// Check whether the remote's underlying transport is connected to the
        /// remote host.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_remote_connected(git_remote remote);
        
        /// <summary>
        /// Cancel the operation
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <remarks>
        /// At certain points in its operation, the network code checks whether
        /// the operation has been cancelled and if so stops the operation.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_remote_stop(git_remote remote);
        
        /// <summary>
        /// Disconnect from the remote
        /// </summary>
        /// <param name="remote">the remote to disconnect from</param>
        /// <remarks>
        /// Close the connection to the remote.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_remote_disconnect(git_remote remote);
        
        /// <summary>
        /// Free the memory associated with a remote
        /// </summary>
        /// <param name="remote">the remote to free</param>
        /// <remarks>
        /// This also disconnects from the remote, if the connection
        /// has not been closed yet (using git_remote_disconnect).
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_remote_free(git_remote remote);
        
        /// <summary>
        /// Get a list of the configured remotes for a repo
        /// </summary>
        /// <param name="@out">a string array which receives the names of the remotes</param>
        /// <param name="repo">the repository to query</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The string array must be freed by the user.
        /// </remarks>
        public static git_result git_remote_list(out string[] @out, git_repository repo)
        {
            git_strarray @out__;
            var __result__ = git_remote_list__(out @out__, repo).Check();
            @out = @out__.ToArray();
            git_strarray_free(ref @out__);
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_list", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_list__(out git_strarray @out, git_repository repo);
        
        /// <summary>
        /// Initializes a `git_remote_callbacks` with default values. Equivalent to
        /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
        /// </summary>
        /// <param name="opts">the `git_remote_callbacks` struct to initialize</param>
        /// <param name="version">Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        public static git_result git_remote_init_callbacks(ref git_remote_callbacks opts, uint version)
        {
            var __result__ = git_remote_init_callbacks__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_init_callbacks", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_init_callbacks__(ref git_remote_callbacks opts, uint version);
        
        /// <summary>
        /// Initialize git_fetch_options structure
        /// </summary>
        /// <param name="opts">The `git_fetch_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_fetch_options` with default values. Equivalent to
        /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_fetch_init_options(ref git_fetch_options opts, uint version)
        {
            var __result__ = git_fetch_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_fetch_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_fetch_init_options__(ref git_fetch_options opts, uint version);
        
        /// <summary>
        /// Initialize git_push_options structure
        /// </summary>
        /// <param name="opts">The `git_push_options` struct to initialize.</param>
        /// <param name="version">The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.</param>
        /// <returns>Zero on success; -1 on failure.</returns>
        /// <remarks>
        /// Initializes a `git_push_options` with default values. Equivalent to
        /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
        /// </remarks>
        public static git_result git_push_init_options(ref git_push_options opts, uint version)
        {
            var __result__ = git_push_init_options__(ref opts, version).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_push_init_options", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_push_init_options__(ref git_push_options opts, uint version);
        
        /// <summary>
        /// Download and index the packfile
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <param name="refspecs">the refspecs to use for this negotiation and
        /// download. Use NULL or an empty array to use the base refspecs</param>
        /// <param name="opts">the options to use for this fetch</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Connect to the remote if it hasn't been done yet, negotiate with
        /// the remote git which objects are missing, download and index the
        /// packfile.The .idx file will be created and both it and the packfile with be
        /// renamed to their final name.
        /// </remarks>
        public static git_result git_remote_download(git_remote remote, string[] refspecs, in git_fetch_options opts)
        {
            var refspecs__ = git_strarray.Allocate(refspecs);
            var __result__ = git_remote_download__(remote, in refspecs__, opts);
            refspecs__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_download", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_download__(git_remote remote, in git_strarray refspecs, in git_fetch_options opts);
        
        /// <summary>
        /// Create a packfile and send it to the server
        /// </summary>
        /// <param name="remote">the remote</param>
        /// <param name="refspecs">the refspecs to use for this negotiation and
        /// upload. Use NULL or an empty array to use the base refspecs</param>
        /// <param name="opts">the options to use for this push</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Connect to the remote if it hasn't been done yet, negotiate with
        /// the remote git which objects are missing, create a packfile with the missing objects and send it.
        /// </remarks>
        public static git_result git_remote_upload(git_remote remote, string[] refspecs, in git_push_options opts)
        {
            var refspecs__ = git_strarray.Allocate(refspecs);
            var __result__ = git_remote_upload__(remote, in refspecs__, opts);
            refspecs__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_upload", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_upload__(git_remote remote, in git_strarray refspecs, in git_push_options opts);
        
        /// <summary>
        /// Update the tips to the new state
        /// </summary>
        /// <param name="remote">the remote to update</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If
        /// NULL and fetching, the default is "fetch 
        /// &lt;name
        /// &gt;", where 
        /// &lt;name
        /// &gt; is
        /// the name of the remote (or its url, for in-memory remotes). This
        /// parameter is ignored when pushing.</param>
        /// <param name="callbacks">pointer to the callback structure to use</param>
        /// <param name="update_fetchhead">whether to write to FETCH_HEAD. Pass 1 to behave like git.</param>
        /// <param name="download_tags">what the behaviour for downloading tags is for this fetch. This is
        /// ignored for push. This must be the same value passed to `git_remote_download()`.</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_remote_update_tips(git_remote remote, in git_remote_callbacks callbacks, int update_fetchhead, git_remote_autotag_option_t download_tags, [MarshalAs(UnmanagedType.LPUTF8Str)] string reflog_message)
        {
            var __result__ = git_remote_update_tips__(remote, callbacks, update_fetchhead, download_tags, reflog_message).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_update_tips", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_update_tips__(git_remote remote, in git_remote_callbacks callbacks, int update_fetchhead, git_remote_autotag_option_t download_tags, [MarshalAs(UnmanagedType.LPUTF8Str)] string reflog_message);
        
        /// <summary>
        /// Download new data and update tips
        /// </summary>
        /// <param name="remote">the remote to fetch from</param>
        /// <param name="refspecs">the refspecs to use for this fetch. Pass NULL or an
        /// empty array to use the base refspecs.</param>
        /// <param name="opts">options to use for this fetch</param>
        /// <param name="reflog_message">The message to insert into the reflogs. If NULL, the
        /// default is "fetch"</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Convenience function to connect to a remote, download the data,
        /// disconnect and update the remote-tracking branches.
        /// </remarks>
        public static git_result git_remote_fetch(git_remote remote, string[] refspecs, in git_fetch_options opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string reflog_message)
        {
            var refspecs__ = git_strarray.Allocate(refspecs);
            var __result__ = git_remote_fetch__(remote, in refspecs__, opts, reflog_message);
            refspecs__.Free();
            __result__.Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_fetch", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_fetch__(git_remote remote, in git_strarray refspecs, in git_fetch_options opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string reflog_message);
        
        /// <summary>
        /// Prune tracking refs that are no longer present on remote
        /// </summary>
        /// <param name="remote">the remote to prune</param>
        /// <param name="callbacks">callbacks to use for this prune</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_remote_prune(git_remote remote, in git_remote_callbacks callbacks)
        {
            var __result__ = git_remote_prune__(remote, callbacks).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_prune", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_prune__(git_remote remote, in git_remote_callbacks callbacks);
        
        /// <summary>
        /// Perform a push
        /// </summary>
        /// <param name="remote">the remote to push to</param>
        /// <param name="refspecs">the refspecs to use for pushing. If NULL or an empty
        /// array, the configured refspecs will be used</param>
        /// <param name="opts">options to use for this push</param>
        /// <remarks>
        /// Peform all the steps from a push.
        /// </remarks>
        public static int git_remote_push(git_remote remote, string[] refspecs, in git_push_options opts)
        {
            var refspecs__ = git_strarray.Allocate(refspecs);
            var __result__ = git_remote_push__(remote, in refspecs__, opts);
            refspecs__.Free();
            ;
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_push", CallingConvention = CallingConvention.Cdecl)]
        private static extern int git_remote_push__(git_remote remote, in git_strarray refspecs, in git_push_options opts);
        
        /// <summary>
        /// Get the statistics structure that is filled in by the fetch operation.
        /// </summary>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_transfer_progress git_remote_stats(git_remote remote);
        
        /// <summary>
        /// Retrieve the tag auto-follow setting
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <returns>the auto-follow setting</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_remote_autotag_option_t git_remote_autotag(git_remote remote);
        
        /// <summary>
        /// Set the remote's tag following setting.
        /// </summary>
        /// <param name="repo">the repository in which to make the change</param>
        /// <param name="remote">the name of the remote</param>
        /// <param name="value">the new value to take.</param>
        /// <remarks>
        /// The change will be made in the configuration. No loaded remotes
        /// will be affected.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_remote_set_autotag(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string remote, git_remote_autotag_option_t value);
        
        /// <summary>
        /// Retrieve the ref-prune setting
        /// </summary>
        /// <param name="remote">the remote to query</param>
        /// <returns>the ref-prune setting</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_remote_prune_refs(git_remote remote);
        
        /// <summary>
        /// Give the remote a new name
        /// </summary>
        /// <param name="problems">non-default refspecs cannot be renamed and will be
        /// stored here for further processing by the caller. Always free this
        /// strarray on successful return.</param>
        /// <param name="repo">the repository in which to rename</param>
        /// <param name="name">the current name of the remote</param>
        /// <param name="new_name">the new name the remote should bear</param>
        /// <returns>0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote are updated.The new name will be checked for validity.
        /// See `git_tag_create()` for rules about valid names.No loaded instances of a the remote with the old name will change
        /// their name or their list of refspecs.
        /// </remarks>
        public static git_result git_remote_rename(out string[] problems, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_name)
        {
            git_strarray problems__;
            var __result__ = git_remote_rename__(out problems__, repo, name, new_name).Check();
            problems = problems__.ToArray();
            git_strarray_free(ref problems__);
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_rename", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_rename__(out git_strarray problems, git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string new_name);
        
        /// <summary>
        /// Ensure the remote name is well-formed.
        /// </summary>
        /// <param name="remote_name">name to be checked.</param>
        /// <returns>1 if the reference name is acceptable; 0 if it isn't</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_remote_is_valid_name([MarshalAs(UnmanagedType.LPUTF8Str)] string remote_name);
        
        /// <summary>
        /// Delete an existing persisted remote.
        /// </summary>
        /// <param name="repo">the repository in which to act</param>
        /// <param name="name">the name of the remote to delete</param>
        /// <returns>0 on success, or an error code.</returns>
        /// <remarks>
        /// All remote-tracking branches and configuration settings
        /// for the remote will be removed.
        /// </remarks>
        public static git_result git_remote_delete(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name)
        {
            var __result__ = git_remote_delete__(repo, name).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_delete", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_delete__(git_repository repo, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);
        
        /// <summary>
        /// Retrieve the name of the remote's default branch
        /// </summary>
        /// <param name="@out">the buffern in which to store the reference name</param>
        /// <param name="remote">the remote</param>
        /// <returns>0, GIT_ENOTFOUND if the remote does not have any references
        /// or none of them point to HEAD's commit, or an error message.</returns>
        /// <remarks>
        /// The default branch of a repository is the branch which HEAD points
        /// to. If the remote does not support reporting this information
        /// directly, it performs the guess as git does; that is, if there are
        /// multiple branches which point to the same commit, the first one is
        /// chosen. If the master branch is a candidate, it wins.This function must only be called after connecting.
        /// </remarks>
        public static git_result git_remote_default_branch(out git_buf @out, git_remote remote)
        {
            var __result__ = git_remote_default_branch__(out @out, remote).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_remote_default_branch", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_remote_default_branch__(out git_buf @out, git_remote remote);
    }
}
