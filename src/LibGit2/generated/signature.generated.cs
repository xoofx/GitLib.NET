//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Create a new action signature.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <param name="time">time (in seconds from epoch) when the action happened</param>
        /// <param name="offset">timezone offset (in minutes) for the time</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.Note: angle brackets ('
        /// &lt;
        /// ' and '&gt;') characters are not allowed
        /// to be used in either the `name` or the `email` parameter.
        /// </remarks>
        public static git_result git_signature_new(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string email, git_time_t time, int offset)
        {
            var __result__ = git_signature_new__(out @out, name, email, time, offset).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_signature_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_signature_new__(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string email, git_time_t time, int offset);
        
        /// <summary>
        /// Create a new action signature with a timestamp of 'now'.
        /// </summary>
        /// <param name="out">new signature, in case of error NULL</param>
        /// <param name="name">name of the person</param>
        /// <param name="email">email of the person</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.
        /// </remarks>
        public static git_result git_signature_now(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string email)
        {
            var __result__ = git_signature_now__(out @out, name, email).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_signature_now", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_signature_now__(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string name, [MarshalAs(UnmanagedType.LPUTF8Str)] string email);
        
        /// <summary>
        /// Create a new action signature with default user and now timestamp.
        /// </summary>
        /// <param name="out">new signature</param>
        /// <param name="repo">repository pointer</param>
        /// <returns>0 on success, GIT_ENOTFOUND if config is missing, or error code</returns>
        /// <remarks>
        /// This looks up the user.name and user.email from the configuration and
        /// uses the current time as the timestamp, and creates a new signature
        /// based on that information.  It will return GIT_ENOTFOUND if either the
        /// user.name or user.email are not set.
        /// </remarks>
        public static git_result git_signature_default(out IntPtr @out, git_repository repo)
        {
            var __result__ = git_signature_default__(out @out, repo).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_signature_default", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_signature_default__(out IntPtr @out, git_repository repo);
        
        /// <summary>
        /// Create a new signature by parsing the given buffer, which is
        /// expected to be in the format "Real Name 
        /// &lt;email
        /// &gt; timestamp tzoffset",
        /// where `timestamp` is the number of seconds since the Unix epoch and
        /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
        /// of a colon separator).
        /// </summary>
        /// <param name="out">new signature</param>
        /// <param name="buf">signature string</param>
        /// <returns>0 on success, or an error code</returns>
        public static git_result git_signature_from_buffer(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string buf)
        {
            var __result__ = git_signature_from_buffer__(out @out, buf).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_signature_from_buffer", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_signature_from_buffer__(out IntPtr @out, [MarshalAs(UnmanagedType.LPUTF8Str)] string buf);
        
        /// <summary>
        /// Create a copy of an existing signature.  All internal strings are also
        /// duplicated.
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="sig">signature to duplicate</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Call `git_signature_free()` to free the data.
        /// </remarks>
        public static git_result git_signature_dup(out IntPtr dest, in git_signature sig)
        {
            var __result__ = git_signature_dup__(out dest, sig).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_signature_dup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_signature_dup__(out IntPtr dest, in git_signature sig);
        
        /// <summary>
        /// Free an existing signature.
        /// </summary>
        /// <param name="sig">signature to free</param>
        /// <remarks>
        /// Because the signature is not an opaque structure, it is legal to free it
        /// manually, but be sure to free the "name" and "email" strings in addition
        /// to the structure itself.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_signature_free(ref git_signature sig);
    }
}
