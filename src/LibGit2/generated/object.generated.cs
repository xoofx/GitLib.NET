//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Lookup a reference to one of the objects in a repository.
        /// </summary>
        /// <param name="object">pointer to the looked-up object</param>
        /// <param name="repo">the repository to look up the object</param>
        /// <param name="id">the unique identifier for the object</param>
        /// <param name="type">the type of the object</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The generated reference is owned by the repository and
        /// should be closed with the `git_object_free` method
        /// instead of free'd manually.The 'type' parameter must match the type of the object
        /// in the odb; the method will fail otherwise.
        /// The special value 'GIT_OBJECT_ANY' may be passed to let
        /// the method guess the object's type.
        /// </remarks>
        public static git_result git_object_lookup(out git_object @object, git_repository repo, in git_oid id, git_object_t type)
        {
            var __result__ = git_object_lookup__(out @object, repo, id, type).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_object_lookup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_object_lookup__(out git_object @object, git_repository repo, in git_oid id, git_object_t type);
        
        /// <summary>
        /// Lookup a reference to one of the objects in a repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <param name="object_out">pointer where to store the looked-up object</param>
        /// <param name="repo">the repository to look up the object</param>
        /// <param name="id">a short identifier for the object</param>
        /// <param name="len">the length of the short identifier</param>
        /// <param name="type">the type of the object</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The object obtained will be so that its identifier
        /// matches the first 'len' hexadecimal characters
        /// (packets of 4 bits) of the given 'id'.
        /// 'len' must be at least GIT_OID_MINPREFIXLEN, and
        /// long enough to identify a unique object matching
        /// the prefix; otherwise the method will fail.The generated reference is owned by the repository and
        /// should be closed with the `git_object_free` method
        /// instead of free'd manually.The 'type' parameter must match the type of the object
        /// in the odb; the method will fail otherwise.
        /// The special value 'GIT_OBJECT_ANY' may be passed to let
        /// the method guess the object's type.
        /// </remarks>
        public static git_result git_object_lookup_prefix(out git_object object_out, git_repository repo, in git_oid id, size_t len, git_object_t type)
        {
            var __result__ = git_object_lookup_prefix__(out object_out, repo, id, len, type).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_object_lookup_prefix", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_object_lookup_prefix__(out git_object object_out, git_repository repo, in git_oid id, size_t len, git_object_t type);
        
        /// <summary>
        /// Lookup an object that represents a tree entry.
        /// </summary>
        /// <param name="out">buffer that receives a pointer to the object (which must be freed
        /// by the caller)</param>
        /// <param name="treeish">root object that can be peeled to a tree</param>
        /// <param name="path">relative path from the root object to the desired object</param>
        /// <param name="type">type of object desired</param>
        /// <returns>0 on success, or an error code</returns>
        public static git_result git_object_lookup_bypath(out git_object @out, git_object treeish, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, git_object_t type)
        {
            var __result__ = git_object_lookup_bypath__(out @out, treeish, path, type).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_object_lookup_bypath", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_object_lookup_bypath__(out git_object @out, git_object treeish, [MarshalAs(UnmanagedType.LPUTF8Str)] string path, git_object_t type);
        
        /// <summary>
        /// Get the id (SHA1) of a repository object
        /// </summary>
        /// <param name="obj">the repository object</param>
        /// <returns>the SHA1 id</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_object_id(git_object obj);
        
        /// <summary>
        /// Get a short abbreviated OID string for the object
        /// </summary>
        /// <param name="out">Buffer to write string into</param>
        /// <param name="obj">The object to get an ID for</param>
        /// <returns>0 on success, 
        /// &lt;
        /// 0 for error</returns>
        /// <remarks>
        /// This starts at the "core.abbrev" length (default 7 characters) and
        /// iteratively extends to a longer string if that length is ambiguous.
        /// The result will be unambiguous (at least until new objects are added to
        /// the repository).
        /// </remarks>
        public static git_result git_object_short_id(out git_buf @out, git_object obj)
        {
            var __result__ = git_object_short_id__(out @out, obj).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_object_short_id", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_object_short_id__(out git_buf @out, git_object obj);
        
        /// <summary>
        /// Get the object type of an object
        /// </summary>
        /// <param name="obj">the repository object</param>
        /// <returns>the object's type</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_object_t git_object_type(git_object obj);
        
        /// <summary>
        /// Get the repository that owns this object
        /// </summary>
        /// <param name="obj">the object</param>
        /// <returns>the repository who owns this object</returns>
        /// <remarks>
        /// Freeing or calling `git_repository_close` on the
        /// returned pointer will invalidate the actual object.Any other operation may be run on the repository without
        /// affecting the object.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_object_owner(git_object obj);
        
        /// <summary>
        /// Close an open object
        /// </summary>
        /// <param name="object">the object to close</param>
        /// <remarks>
        /// This method instructs the library to close an existing
        /// object; note that git_objects are owned and cached by the repository
        /// so the object may or may not be freed after this library call,
        /// depending on how aggressive is the caching mechanism used
        /// by the repository.IMPORTANT:
        /// It *is* necessary to call this method when you stop using
        /// an object. Failure to do so will cause a memory leak.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_object_free(git_object @object);
        
        /// <summary>
        /// Convert an object type to its string representation.
        /// </summary>
        /// <param name="type">object type to convert.</param>
        /// <returns>the corresponding string representation.</returns>
        /// <remarks>
        /// The result is a pointer to a string in static memory and
        /// should not be free()'ed.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_object_type2string(git_object_t type);
        
        /// <summary>
        /// Convert a string object type representation to it's git_object_t.
        /// </summary>
        /// <param name="str">the string to convert.</param>
        /// <returns>the corresponding git_object_t.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_object_t git_object_string2type([MarshalAs(UnmanagedType.LPUTF8Str)] string str);
        
        /// <summary>
        /// Determine if the given git_object_t is a valid loose object type.
        /// </summary>
        /// <param name="type">object type to test.</param>
        /// <returns>true if the type represents a valid loose object type,
        /// false otherwise.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_object_typeisloose(git_object_t type);
        
        /// <summary>
        /// Get the size in bytes for the structure which
        /// acts as an in-memory representation of any given
        /// object type.
        /// </summary>
        /// <param name="type">object type to get its size</param>
        /// <returns>size in bytes of the object</returns>
        /// <remarks>
        /// For all the core types, this would the equivalent
        /// of calling `sizeof(git_commit)` if the core types
        /// were not opaque on the external API.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern size_t git_object__size(git_object_t type);
        
        /// <summary>
        /// Recursively peel an object until an object of the specified type is met.
        /// </summary>
        /// <param name="peeled">Pointer to the peeled git_object</param>
        /// <param name="object">The object to be processed</param>
        /// <param name="target_type">The type of the requested object (a GIT_OBJECT_ value)</param>
        /// <returns>0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code</returns>
        /// <remarks>
        /// If the query cannot be satisfied due to the object model,
        /// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
        /// tree).If you pass `GIT_OBJECT_ANY` as the target type, then the object will
        /// be peeled until the type changes. A tag will be peeled until the
        /// referenced object is no longer a tag, and a commit will be peeled
        /// to a tree. Any other object type will return GIT_EINVALIDSPEC.If peeling a tag we discover an object which cannot be peeled to
        /// the target type due to the object model, GIT_EPEEL will be
        /// returned.You must free the returned object.
        /// </remarks>
        public static git_result git_object_peel(out git_object peeled, git_object @object, git_object_t target_type)
        {
            var __result__ = git_object_peel__(out peeled, @object, target_type).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_object_peel", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_object_peel__(out git_object peeled, git_object @object, git_object_t target_type);
        
        /// <summary>
        /// Create an in-memory copy of a Git object. The copy must be
        /// explicitly free'd or it will leak.
        /// </summary>
        /// <param name="dest">Pointer to store the copy of the object</param>
        /// <param name="source">Original object to copy</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_object_dup(out git_object dest, git_object source);
    }
}
