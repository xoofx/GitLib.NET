//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibGit2
{
    using System.Runtime.InteropServices;
    
    public static partial class libgit2
    {
        /// <summary>
        /// Tree traversal modes
        /// </summary>
        public enum git_treewalk_mode : int
        {
            /// <summary>
            /// Pre-order
            /// </summary>
            GIT_TREEWALK_PRE = (int)0,
            
            /// <summary>
            /// Post-order
            /// </summary>
            GIT_TREEWALK_POST = (int)1,
        }
        
        /// <summary>
        /// Pre-order
        /// </summary>
        public const git_treewalk_mode GIT_TREEWALK_PRE = git_treewalk_mode.GIT_TREEWALK_PRE;
        
        /// <summary>
        /// Post-order
        /// </summary>
        public const git_treewalk_mode GIT_TREEWALK_POST = git_treewalk_mode.GIT_TREEWALK_POST;
        
        /// <summary>
        /// The kind of update to perform
        /// </summary>
        public enum git_tree_update_t : int
        {
            /// <summary>
            /// Update or insert an entry at the specified path
            /// </summary>
            GIT_TREE_UPDATE_UPSERT,
            
            /// <summary>
            /// Remove an entry from the specified path
            /// </summary>
            GIT_TREE_UPDATE_REMOVE,
        }
        
        /// <summary>
        /// Update or insert an entry at the specified path
        /// </summary>
        public const git_tree_update_t GIT_TREE_UPDATE_UPSERT = git_tree_update_t.GIT_TREE_UPDATE_UPSERT;
        
        /// <summary>
        /// Remove an entry from the specified path
        /// </summary>
        public const git_tree_update_t GIT_TREE_UPDATE_REMOVE = git_tree_update_t.GIT_TREE_UPDATE_REMOVE;
        
        /// <summary>
        /// An action to perform during the update of a tree
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct git_tree_update
        {
            /// <summary>
            /// Update action. If it's an removal, only the path is looked at
            /// </summary>
            public git_tree_update_t action;
            
            /// <summary>
            /// The entry's id
            /// </summary>
            public git_oid id;
            
            /// <summary>
            /// The filemode/kind of object
            /// </summary>
            public git_filemode_t filemode;
            
            /// <summary>
            /// The full path from the root tree
            /// </summary>
            [MarshalAs(UnmanagedType.LPUTF8Str)]
            public string path;
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_treebuilder_filter_cb(git_tree_entry entry, IntPtr payload);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int git_treewalk_cb([MarshalAs(UnmanagedType.LPUTF8Str)] string root, git_tree_entry entry, IntPtr payload);
        
        /// <summary>
        /// Lookup a tree object from the repository.
        /// </summary>
        /// <param name="@out">Pointer to the looked up tree</param>
        /// <param name="repo">The repo to use when locating the tree.</param>
        /// <param name="id">Identity of the tree to locate.</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_tree_lookup(out git_tree @out, git_repository repo, in git_oid id)
        {
            var __result__ = git_tree_lookup__(out @out, repo, id).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_tree_lookup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_tree_lookup__(out git_tree @out, git_repository repo, in git_oid id);
        
        /// <summary>
        /// Lookup a tree object from the repository,
        /// given a prefix of its identifier (short id).
        /// </summary>
        /// <seealso cref="git_object_lookup_prefix"/>
        /// 
        /// <param name="@out">pointer to the looked up tree</param>
        /// <param name="repo">the repo to use when locating the tree.</param>
        /// <param name="id">identity of the tree to locate.</param>
        /// <param name="len">the length of the short identifier</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_tree_lookup_prefix(out git_tree @out, git_repository repo, in git_oid id, size_t len)
        {
            var __result__ = git_tree_lookup_prefix__(out @out, repo, id, len).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_tree_lookup_prefix", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_tree_lookup_prefix__(out git_tree @out, git_repository repo, in git_oid id, size_t len);
        
        /// <summary>
        /// Close an open tree
        /// </summary>
        /// <param name="tree">The tree to close</param>
        /// <remarks>
        /// You can no longer use the git_tree pointer after this call.IMPORTANT: You MUST call this method when you stop using a tree to
        /// release memory. Failure to do so will cause a memory leak.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_tree_free(git_tree tree);
        
        /// <summary>
        /// Get the id of a tree.
        /// </summary>
        /// <param name="tree">a previously loaded tree.</param>
        /// <returns>object identity for the tree.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_tree_id(git_tree tree);
        
        /// <summary>
        /// Get the repository that contains the tree.
        /// </summary>
        /// <param name="tree">A previously loaded tree.</param>
        /// <returns>Repository that contains this tree.</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_repository git_tree_owner(git_tree tree);
        
        /// <summary>
        /// Get the number of entries listed in a tree
        /// </summary>
        /// <param name="tree">a previously loaded tree.</param>
        /// <returns>the number of entries in the tree</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern size_t git_tree_entrycount(git_tree tree);
        
        /// <summary>
        /// Lookup a tree entry by its filename
        /// </summary>
        /// <param name="tree">a previously loaded tree.</param>
        /// <param name="filename">the filename of the desired entry</param>
        /// <returns>the tree entry; NULL if not found</returns>
        /// <remarks>
        /// This returns a git_tree_entry that is owned by the git_tree.  You don't
        /// have to free it, but you must not use it after the git_tree is released.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_tree_entry git_tree_entry_byname(git_tree tree, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename);
        
        /// <summary>
        /// Lookup a tree entry by its position in the tree
        /// </summary>
        /// <param name="tree">a previously loaded tree.</param>
        /// <param name="idx">the position in the entry list</param>
        /// <returns>the tree entry; NULL if not found</returns>
        /// <remarks>
        /// This returns a git_tree_entry that is owned by the git_tree.  You don't
        /// have to free it, but you must not use it after the git_tree is released.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_tree_entry git_tree_entry_byindex(git_tree tree, size_t idx);
        
        /// <summary>
        /// Lookup a tree entry by SHA value.
        /// </summary>
        /// <param name="tree">a previously loaded tree.</param>
        /// <param name="id">the sha being looked for</param>
        /// <returns>the tree entry; NULL if not found</returns>
        /// <remarks>
        /// This returns a git_tree_entry that is owned by the git_tree.  You don't
        /// have to free it, but you must not use it after the git_tree is released.Warning: this must examine every entry in the tree, so it is not fast.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_tree_entry git_tree_entry_byid(git_tree tree, in git_oid id);
        
        /// <summary>
        /// Retrieve a tree entry contained in a tree or in any of its subtrees,
        /// given its relative path.
        /// </summary>
        /// <param name="@out">Pointer where to store the tree entry</param>
        /// <param name="root">Previously loaded tree which is the root of the relative path</param>
        /// <param name="path">Path to the contained entry</param>
        /// <returns>0 on success; GIT_ENOTFOUND if the path does not exist</returns>
        /// <remarks>
        /// Unlike the other lookup functions, the returned tree entry is owned by
        /// the user and must be freed explicitly with `git_tree_entry_free()`.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_tree_entry_bypath(out git_tree_entry @out, git_tree root, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);
        
        /// <summary>
        /// Duplicate a tree entry
        /// </summary>
        /// <param name="dest">pointer where to store the copy</param>
        /// <param name="source">tree entry to duplicate</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Create a copy of a tree entry. The returned copy is owned by the user,
        /// and must be freed explicitly with `git_tree_entry_free()`.
        /// </remarks>
        public static git_result git_tree_entry_dup(out git_tree_entry dest, git_tree_entry source)
        {
            var __result__ = git_tree_entry_dup__(out dest, source).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_tree_entry_dup", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_tree_entry_dup__(out git_tree_entry dest, git_tree_entry source);
        
        /// <summary>
        /// Free a user-owned tree entry
        /// </summary>
        /// <param name="entry">The entry to free</param>
        /// <remarks>
        /// IMPORTANT: This function is only needed for tree entries owned by the
        /// user, such as the ones returned by `git_tree_entry_dup()` or
        /// `git_tree_entry_bypath()`.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_tree_entry_free(git_tree_entry entry);
        
        /// <summary>
        /// Get the filename of a tree entry
        /// </summary>
        /// <param name="entry">a tree entry</param>
        /// <returns>the name of the file</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.LPUTF8Str)]
        public static extern string git_tree_entry_name(git_tree_entry entry);
        
        /// <summary>
        /// Get the id of the object pointed by the entry
        /// </summary>
        /// <param name="entry">a tree entry</param>
        /// <returns>the oid of the object</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly git_oid git_tree_entry_id(git_tree_entry entry);
        
        /// <summary>
        /// Get the type of the object pointed by the entry
        /// </summary>
        /// <param name="entry">a tree entry</param>
        /// <returns>the type of the pointed object</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_object_t git_tree_entry_type(git_tree_entry entry);
        
        /// <summary>
        /// Get the UNIX file attributes of a tree entry
        /// </summary>
        /// <param name="entry">a tree entry</param>
        /// <returns>filemode as an integer</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_filemode_t git_tree_entry_filemode(git_tree_entry entry);
        
        /// <summary>
        /// Get the raw UNIX file attributes of a tree entry
        /// </summary>
        /// <param name="entry">a tree entry</param>
        /// <returns>filemode as an integer</returns>
        /// <remarks>
        /// This function does not perform any normalization and is only useful
        /// if you need to be able to recreate the original tree object.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_filemode_t git_tree_entry_filemode_raw(git_tree_entry entry);
        
        /// <summary>
        /// Compare two tree entries
        /// </summary>
        /// <param name="e1">first tree entry</param>
        /// <param name="e2">second tree entry</param>
        /// <returns>&lt;
        /// 0 if e1 is before e2, 0 if e1 == e2, &gt;0 if e1 is after e2</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_tree_entry_cmp(git_tree_entry e1, git_tree_entry e2);
        
        /// <summary>
        /// Convert a tree entry to the git_object it points to.
        /// </summary>
        /// <param name="object_out">pointer to the converted object</param>
        /// <param name="repo">repository where to lookup the pointed object</param>
        /// <param name="entry">a tree entry</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// You must call `git_object_free()` on the object when you are done with it.
        /// </remarks>
        public static git_result git_tree_entry_to_object(out git_object object_out, git_repository repo, git_tree_entry entry)
        {
            var __result__ = git_tree_entry_to_object__(out object_out, repo, entry).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_tree_entry_to_object", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_tree_entry_to_object__(out git_object object_out, git_repository repo, git_tree_entry entry);
        
        /// <summary>
        /// Create a new tree builder.
        /// </summary>
        /// <param name="@out">Pointer where to store the tree builder</param>
        /// <param name="repo">Repository in which to store the object</param>
        /// <param name="source">Source tree to initialize the builder (optional)</param>
        /// <returns>0 on success; error code otherwise</returns>
        /// <remarks>
        /// The tree builder can be used to create or modify trees in memory and
        /// write them as tree objects to the database.If the `source` parameter is not NULL, the tree builder will be
        /// initialized with the entries of the given tree.If the `source` parameter is NULL, the tree builder will start with no
        /// entries and will have to be filled manually.
        /// </remarks>
        public static git_result git_treebuilder_new(out git_treebuilder @out, git_repository repo, git_tree source)
        {
            var __result__ = git_treebuilder_new__(out @out, repo, source).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_treebuilder_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_treebuilder_new__(out git_treebuilder @out, git_repository repo, git_tree source);
        
        /// <summary>
        /// Clear all the entires in the builder
        /// </summary>
        /// <param name="bld">Builder to clear</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_treebuilder_clear(git_treebuilder bld);
        
        /// <summary>
        /// Get the number of entries listed in a treebuilder
        /// </summary>
        /// <param name="bld">a previously loaded treebuilder.</param>
        /// <returns>the number of entries in the treebuilder</returns>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint git_treebuilder_entrycount(git_treebuilder bld);
        
        /// <summary>
        /// Free a tree builder
        /// </summary>
        /// <param name="bld">Builder to free</param>
        /// <remarks>
        /// This will clear all the entries and free to builder.
        /// Failing to free the builder after you're done using it
        /// will result in a memory leak
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_treebuilder_free(git_treebuilder bld);
        
        /// <summary>
        /// Get an entry from the builder from its filename
        /// </summary>
        /// <param name="bld">Tree builder</param>
        /// <param name="filename">Name of the entry</param>
        /// <returns>pointer to the entry; NULL if not found</returns>
        /// <remarks>
        /// The returned entry is owned by the builder and should
        /// not be freed manually.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern git_tree_entry git_treebuilder_get(git_treebuilder bld, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename);
        
        /// <summary>
        /// Add or update an entry to the builder
        /// </summary>
        /// <param name="@out">Pointer to store the entry (optional)</param>
        /// <param name="bld">Tree builder</param>
        /// <param name="filename">Filename of the entry</param>
        /// <param name="id">SHA1 oid of the entry</param>
        /// <param name="filemode">Folder attributes of the entry. This parameter must
        /// be valued with one of the following entries: 0040000, 0100644,
        /// 0100755, 0120000 or 0160000.</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// Insert a new entry for `filename` in the builder with the
        /// given attributes.If an entry named `filename` already exists, its attributes
        /// will be updated with the given ones.The optional pointer `out` can be used to retrieve a pointer to the
        /// newly created/updated entry.  Pass NULL if you do not need it. The
        /// pointer may not be valid past the next operation in this
        /// builder. Duplicate the entry if you want to keep it.By default the entry that you are inserting will be checked for
        /// validity; that it exists in the object database and is of the
        /// correct type.  If you do not want this behavior, set the
        /// `GIT_OPT_ENABLE_STRICT_OBJECT_CREATION` library option to false.
        /// </remarks>
        public static git_result git_treebuilder_insert(out git_tree_entry @out, git_treebuilder bld, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename, in git_oid id, git_filemode_t filemode)
        {
            var __result__ = git_treebuilder_insert__(out @out, bld, filename, id, filemode).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_treebuilder_insert", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_treebuilder_insert__(out git_tree_entry @out, git_treebuilder bld, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename, in git_oid id, git_filemode_t filemode);
        
        /// <summary>
        /// Remove an entry from the builder by its filename
        /// </summary>
        /// <param name="bld">Tree builder</param>
        /// <param name="filename">Filename of the entry to remove</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_treebuilder_remove(git_treebuilder bld, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename);
        
        /// <summary>
        /// Selectively remove entries in the tree
        /// </summary>
        /// <param name="bld">Tree builder</param>
        /// <param name="filter">Callback to filter entries</param>
        /// <param name="payload">Extra data to pass to filter callback</param>
        /// <remarks>
        /// The `filter` callback will be called for each entry in the tree with a
        /// pointer to the entry and the provided `payload`; if the callback returns
        /// non-zero, the entry will be filtered (removed from the builder).
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern void git_treebuilder_filter(git_treebuilder bld, git_treebuilder_filter_cb filter, IntPtr payload);
        
        /// <summary>
        /// Write the contents of the tree builder as a tree object
        /// </summary>
        /// <param name="id">Pointer to store the OID of the newly written tree</param>
        /// <param name="bld">Tree builder to write</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The tree builder will be written to the given `repo`, and its
        /// identifying SHA1 hash will be stored in the `id` pointer.
        /// </remarks>
        public static git_result git_treebuilder_write(ref git_oid id, git_treebuilder bld)
        {
            var __result__ = git_treebuilder_write__(ref id, bld).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_treebuilder_write", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_treebuilder_write__(ref git_oid id, git_treebuilder bld);
        
        /// <summary>
        /// Write the contents of the tree builder as a tree object
        /// using a shared git_buf.
        /// </summary>
        /// <seealso cref="git_treebuilder_write"/>
        /// 
        /// <param name="oid">Pointer to store the OID of the newly written tree</param>
        /// <param name="bld">Tree builder to write</param>
        /// <param name="tree">Shared buffer for writing the tree. Will be grown as necessary.</param>
        /// <returns>0 or an error code</returns>
        public static git_result git_treebuilder_write_with_buffer(ref git_oid oid, git_treebuilder bld, ref git_buf tree)
        {
            var __result__ = git_treebuilder_write_with_buffer__(ref oid, bld, ref tree).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_treebuilder_write_with_buffer", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_treebuilder_write_with_buffer__(ref git_oid oid, git_treebuilder bld, ref git_buf tree);
        
        /// <summary>
        /// Traverse the entries in a tree and its subtrees in post or pre order.
        /// </summary>
        /// <param name="tree">The tree to walk</param>
        /// <param name="mode">Traversal mode (pre or post-order)</param>
        /// <param name="callback">Function to call on each tree entry</param>
        /// <param name="payload">Opaque pointer to be passed on each callback</param>
        /// <returns>0 or an error code</returns>
        /// <remarks>
        /// The entries will be traversed in the specified order, children subtrees
        /// will be automatically loaded as required, and the `callback` will be
        /// called once per entry with the current (relative) root for the entry and
        /// the entry data itself.If the callback returns a positive value, the passed entry will be
        /// skipped on the traversal (in pre mode). A negative value stops the walk.
        /// </remarks>
        public static git_result git_tree_walk(git_tree tree, git_treewalk_mode mode, git_treewalk_cb callback, IntPtr payload)
        {
            var __result__ = git_tree_walk__(tree, mode, callback, payload).Check();
            return __result__;
        }
        
        [DllImport(LibGit2Name, EntryPoint = "git_tree_walk", CallingConvention = CallingConvention.Cdecl)]
        private static extern git_result git_tree_walk__(git_tree tree, git_treewalk_mode mode, git_treewalk_cb callback, IntPtr payload);
        
        /// <summary>
        /// Create an in-memory copy of a tree. The copy must be explicitly
        /// free'd or it will leak.
        /// </summary>
        /// <param name="@out">Pointer to store the copy of the tree</param>
        /// <param name="source">Original tree to copy</param>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_tree_dup(out git_tree @out, git_tree source);
        
        /// <summary>
        /// Create a tree based on another one with the specified modifications
        /// </summary>
        /// <param name="@out">id of the new tree</param>
        /// <param name="repo">the repository in which to create the tree, must be the
        /// same as for `baseline`</param>
        /// <param name="baseline">the tree to base these changes on</param>
        /// <param name="nupdates">the number of elements in the update list</param>
        /// <param name="updates">the list of updates to perform</param>
        /// <remarks>
        /// Given the `baseline` perform the changes described in the list of
        /// `updates` and create a new tree.This function is optimized for common file/directory addition, removal and
        /// replacement in trees. It is much more efficient than reading the tree into a
        /// `git_index` and modifying that, but in exchange it is not as flexible.Deleting and adding the same entry is undefined behaviour, changing
        /// a tree to a blob or viceversa is not supported.
        /// </remarks>
        [DllImport(LibGit2Name, CallingConvention = CallingConvention.Cdecl)]
        public static extern int git_tree_create_updated(out git_oid @out, git_repository repo, git_tree baseline, size_t nupdates, in git_tree_update updates);
    }
}
